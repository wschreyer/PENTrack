
/**
 * \file
 * Implementation of a magnetic field determined by 
 * coefficients, provided as inputs by the user, of an expansion in
 * terms of harmonic polynomials.
*/

#include "harmonicfields.h"
#include <iostream>
#include <cmath>
#include <boost/math/quaternion.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <boost/math/differentiation/autodiff.hpp>
#include <boost/math/special_functions/factorials.hpp>
#include <boost/math/special_functions/legendre.hpp>

HarmonicExpandedBField::HarmonicExpandedBField(const double _xoff, const double _yoff, const double _zoff,
		const double _axis_x, const double _axis_y, const double _axis_z, const double _angle,
		const std::vector<std::tuple<int, int, double> > _Glm){
	
	if (_Glm.empty()){
		std::cerr << "Warning: you have defined a HarmonicExpansionBField with no coefficients. It will always evaluate to zero!";
	}

	if (_axis_x != 0. or _axis_y != 0. or _axis_z != 0. or _angle != 0.){
		throw std::runtime_error("I'm afraid the field rotations for the HarmonicExpandedBField are not implemented yet! Please set all rotation parameters to zero. Aborting...");
	}

	// the offset values
	xoff = _xoff;
	yoff = _yoff;
	zoff = _zoff;

	// parameters defining the axis-angle quaternion rotation
	axis_x = _axis_x;
	axis_y = _axis_y;
	axis_z = _axis_z;
	angle  = _angle;

	Glm = _Glm;

	for (auto glm: Glm){
		int l = std::get<0>(glm);
		int m = std::get<1>(glm);
		if (l < 0 or l > 5 or std::abs(m) > l + 1){
			throw std::runtime_error("You defined invalid HarmonicExpansionBField coefficients (l,m) = (" + std::to_string(l) + "," + std::to_string(m) + ")! Only values 0 <= l <= 5 and -l-1 <= m <= l+1 are allowed. Aborting...");
		}
	}
}


void HarmonicExpandedBField::BField(const double _x, const double _y, const double _z, const double t, double B[3], double dBidxj[3][3]) const{
	// Updating the x, y, z values with the given offset values
	double x = _x + xoff;
	double y = _y + yoff;
	double z = _z + zoff;

	for (int i = 0; i < 3; ++i){
		B[i] = 0;
		for (int j = 0; j < 3 and dBidxj != nullptr; ++j){
			dBidxj[i][j] = 0;
		}
	}

	for (auto glm: Glm){
		int l = std::get<0>(glm);
		int m = std::get<1>(glm);
		double G = std::get<2>(glm);

		if (G == 0.) continue;

		/* 
		 * The code below is autogenerated using Mathematica with the goal to allow the user to define an arbitrary set of Glm coeffcients up to 5th order.
		 * I tried to implement a general solution with associated Legendre polynomials but the expressions become extremely complicated, especially for the field gradients.
		 * This is hopefully faster.
		 * For more information about the harmonic polynomial decomposition see https://doi.org/10.1103/PhysRevA.99.042112
		*/
		if (l==0){
			if (m==-1){
				B[0] += 0;
				B[1] += G;
				B[2] += 0;
			}
			else if (m==0){
				B[0] += 0;
				B[1] += 0;
				B[2] += G;
			}
			else if (m==1){
				B[0] += G;
				B[1] += 0;
				B[2] += 0;
			}
		}
		else if (l==1){
			if (m==-2){
				B[0] += G*y;
				B[1] += G*x;
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 0;
					dBidxj[0][1] += G;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G;
					dBidxj[1][1] += 0;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-1){
				B[0] += 0;
				B[1] += G*z;
				B[2] += G*y;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 0;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += 0;
					dBidxj[1][2] += G;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += G;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==0){
				B[0] += -(G*x)/2.;
				B[1] += -(G*y)/2.;
				B[2] += G*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += -G/2.;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += -G/2.;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += G;
				}
			}
			else if (m==1){
				B[0] += G*z;
				B[1] += 0;
				B[2] += G*x;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 0;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += G;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += 0;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += G;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==2){
				B[0] += G*x;
				B[1] += -(G*y);
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += -G;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else if (l==2){
			if (m==-3){
				B[0] += 2*G*x*y;
				B[1] += G*(x - y)*(x + y);
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 2*G*y;
					dBidxj[0][1] += 2*G*x;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += 2*G*x;
					dBidxj[1][1] += -2*G*y;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-2){
				B[0] += 2*G*y*z;
				B[1] += 2*G*x*z;
				B[2] += 2*G*x*y;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 0;
					dBidxj[0][1] += 2*G*z;
					dBidxj[0][2] += 2*G*y;
					dBidxj[1][0] += 2*G*z;
					dBidxj[1][1] += 0;
					dBidxj[1][2] += 2*G*x;
					dBidxj[2][0] += 2*G*y;
					dBidxj[2][1] += 2*G*x;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-1){
				B[0] += -(G*x*y)/2.;
				B[1] += G*(-std::pow(x,2)/4. - (3*std::pow(y,2))/4. + std::pow(z,2));
				B[2] += 2*G*y*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += -(G*y)/2.;
					dBidxj[0][1] += -(G*x)/2.;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += -(G*x)/2.;
					dBidxj[1][1] += (-3*G*y)/2.;
					dBidxj[1][2] += 2*G*z;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 2*G*z;
					dBidxj[2][2] += 2*G*y;
				}
			}
			else if (m==0){
				B[0] += -(G*x*z);
				B[1] += -(G*y*z);
				B[2] += G*(-std::pow(x,2)/2. - std::pow(y,2)/2. + std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += -(G*z);
					dBidxj[0][1] += 0;
					dBidxj[0][2] += -(G*x);
					dBidxj[1][0] += 0;
					dBidxj[1][1] += -(G*z);
					dBidxj[1][2] += -(G*y);
					dBidxj[2][0] += -(G*x);
					dBidxj[2][1] += -(G*y);
					dBidxj[2][2] += 2*G*z;
				}
			}
			else if (m==1){
				B[0] += G*((-3*std::pow(x,2))/4. - std::pow(y,2)/4. + std::pow(z,2));
				B[1] += -(G*x*y)/2.;
				B[2] += 2*G*x*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (-3*G*x)/2.;
					dBidxj[0][1] += -(G*y)/2.;
					dBidxj[0][2] += 2*G*z;
					dBidxj[1][0] += -(G*y)/2.;
					dBidxj[1][1] += -(G*x)/2.;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 2*G*z;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 2*G*x;
				}
			}
			else if (m==2){
				B[0] += 2*G*x*z;
				B[1] += -2*G*y*z;
				B[2] += G*(x - y)*(x + y);
				if (dBidxj != nullptr){
					dBidxj[0][0] += 2*G*z;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 2*G*x;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += -2*G*z;
					dBidxj[1][2] += -2*G*y;
					dBidxj[2][0] += 2*G*x;
					dBidxj[2][1] += -2*G*y;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==3){
				B[0] += G*(x - y)*(x + y);
				B[1] += -2*G*x*y;
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 2*G*x;
					dBidxj[0][1] += -2*G*y;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += -2*G*y;
					dBidxj[1][1] += -2*G*x;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else if (l==3){
			if (m==-4){
				B[0] += G*(3*std::pow(x,2)*y - std::pow(y,3));
				B[1] += G*(std::pow(x,3) - 3*x*std::pow(y,2));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 6*G*x*y;
					dBidxj[0][1] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[1][1] += -6*G*x*y;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-3){
				B[0] += 6*G*x*y*z;
				B[1] += 3*G*(x - y)*(x + y)*z;
				B[2] += G*(3*std::pow(x,2)*y - std::pow(y,3));
				if (dBidxj != nullptr){
					dBidxj[0][0] += 6*G*y*z;
					dBidxj[0][1] += 6*G*x*z;
					dBidxj[0][2] += 6*G*x*y;
					dBidxj[1][0] += G*(3*(x - y)*z + 3*(x + y)*z);
					dBidxj[1][1] += G*(3*(x - y)*z - 3*(x + y)*z);
					dBidxj[1][2] += 3*G*(x - y)*(x + y);
					dBidxj[2][0] += 6*G*x*y;
					dBidxj[2][1] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-2){
				B[0] += -(G*y*(3*std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.;
				B[1] += -(G*x*(std::pow(x,2) + 3*std::pow(y,2) - 6*std::pow(z,2)))/2.;
				B[2] += 6*G*x*y*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += -3*G*x*y;
					dBidxj[0][1] += G*(-std::pow(y,2) + (-3*std::pow(x,2) - std::pow(y,2) + 6*std::pow(z,2))/2.);
					dBidxj[0][2] += 6*G*y*z;
					dBidxj[1][0] += G*(-std::pow(x,2) + (-std::pow(x,2) - 3*std::pow(y,2) + 6*std::pow(z,2))/2.);
					dBidxj[1][1] += -3*G*x*y;
					dBidxj[1][2] += 6*G*x*z;
					dBidxj[2][0] += 6*G*y*z;
					dBidxj[2][1] += 6*G*x*z;
					dBidxj[2][2] += 6*G*x*y;
				}
			}
			else if (m==-1){
				B[0] += (-3*G*x*y*z)/2.;
				B[1] += G*((-3*(std::pow(x,2) + 3*std::pow(y,2))*z)/4. + std::pow(z,3));
				B[2] += (-3*G*y*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/4.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (-3*G*y*z)/2.;
					dBidxj[0][1] += (-3*G*x*z)/2.;
					dBidxj[0][2] += (-3*G*x*y)/2.;
					dBidxj[1][0] += (-3*G*x*z)/2.;
					dBidxj[1][1] += (-9*G*y*z)/2.;
					dBidxj[1][2] += G*((-3*(std::pow(x,2) + 3*std::pow(y,2)))/4. + 3*std::pow(z,2));
					dBidxj[2][0] += (-3*G*x*y)/2.;
					dBidxj[2][1] += G*((-3*std::pow(y,2))/2. - (3*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/4.);
					dBidxj[2][2] += 6*G*y*z;
				}
			}
			else if (m==0){
				B[0] += (3*G*x*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/8.;
				B[1] += (3*G*y*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/8.;
				B[2] += G*((-3*(std::pow(x,2) + std::pow(y,2))*z)/2. + std::pow(z,3));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((3*std::pow(x,2))/4. + (3*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/8.);
					dBidxj[0][1] += (3*G*x*y)/4.;
					dBidxj[0][2] += -3*G*x*z;
					dBidxj[1][0] += (3*G*x*y)/4.;
					dBidxj[1][1] += G*((3*std::pow(y,2))/4. + (3*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/8.);
					dBidxj[1][2] += -3*G*y*z;
					dBidxj[2][0] += -3*G*x*z;
					dBidxj[2][1] += -3*G*y*z;
					dBidxj[2][2] += G*((-3*(std::pow(x,2) + std::pow(y,2)))/2. + 3*std::pow(z,2));
				}
			}
			else if (m==1){
				B[0] += G*((-3*(3*std::pow(x,2) + std::pow(y,2))*z)/4. + std::pow(z,3));
				B[1] += (-3*G*x*y*z)/2.;
				B[2] += (-3*G*x*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/4.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (-9*G*x*z)/2.;
					dBidxj[0][1] += (-3*G*y*z)/2.;
					dBidxj[0][2] += G*((-3*(3*std::pow(x,2) + std::pow(y,2)))/4. + 3*std::pow(z,2));
					dBidxj[1][0] += (-3*G*y*z)/2.;
					dBidxj[1][1] += (-3*G*x*z)/2.;
					dBidxj[1][2] += (-3*G*x*y)/2.;
					dBidxj[2][0] += G*((-3*std::pow(x,2))/2. - (3*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/4.);
					dBidxj[2][1] += (-3*G*x*y)/2.;
					dBidxj[2][2] += 6*G*x*z;
				}
			}
			else if (m==2){
				B[0] += G*(-std::pow(x,3) + 3*x*std::pow(z,2));
				B[1] += G*(std::pow(y,3) - 3*y*std::pow(z,2));
				B[2] += 3*G*(x - y)*(x + y)*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-3*std::pow(x,2) + 3*std::pow(z,2));
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 6*G*x*z;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += G*(3*std::pow(y,2) - 3*std::pow(z,2));
					dBidxj[1][2] += -6*G*y*z;
					dBidxj[2][0] += G*(3*(x - y)*z + 3*(x + y)*z);
					dBidxj[2][1] += G*(3*(x - y)*z - 3*(x + y)*z);
					dBidxj[2][2] += 3*G*(x - y)*(x + y);
				}
			}
			else if (m==3){
				B[0] += 3*G*(x - y)*(x + y)*z;
				B[1] += -6*G*x*y*z;
				B[2] += G*(std::pow(x,3) - 3*x*std::pow(y,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(3*(x - y)*z + 3*(x + y)*z);
					dBidxj[0][1] += G*(3*(x - y)*z - 3*(x + y)*z);
					dBidxj[0][2] += 3*G*(x - y)*(x + y);
					dBidxj[1][0] += -6*G*y*z;
					dBidxj[1][1] += -6*G*x*z;
					dBidxj[1][2] += -6*G*x*y;
					dBidxj[2][0] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[2][1] += -6*G*x*y;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==4){
				B[0] += G*(std::pow(x,3) - 3*x*std::pow(y,2));
				B[1] += G*(-3*std::pow(x,2)*y + std::pow(y,3));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[0][1] += -6*G*x*y;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += -6*G*x*y;
					dBidxj[1][1] += G*(-3*std::pow(x,2) + 3*std::pow(y,2));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else if (l==4){
			if (m==-5){
				B[0] += 4*G*x*(x - y)*y*(x + y);
				B[1] += G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(4*x*(x - y)*y + 4*x*y*(x + y) + 4*(x - y)*y*(x + y));
					dBidxj[0][1] += G*(4*x*(x - y)*y + 4*x*(x - y)*(x + y) - 4*x*y*(x + y));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G*(4*std::pow(x,3) - 12*x*std::pow(y,2));
					dBidxj[1][1] += G*(-12*std::pow(x,2)*y + 4*std::pow(y,3));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-4){
				B[0] += -4*G*y*(-3*std::pow(x,2) + std::pow(y,2))*z;
				B[1] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
				B[2] += 4*G*x*(x - y)*y*(x + y);
				if (dBidxj != nullptr){
					dBidxj[0][0] += 24*G*x*y*z;
					dBidxj[0][1] += G*(-8*std::pow(y,2)*z - 4*(-3*std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[0][2] += -4*G*y*(-3*std::pow(x,2) + std::pow(y,2));
					dBidxj[1][0] += G*(8*std::pow(x,2)*z + 4*(std::pow(x,2) - 3*std::pow(y,2))*z);
					dBidxj[1][1] += -24*G*x*y*z;
					dBidxj[1][2] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[2][0] += G*(4*x*(x - y)*y + 4*x*y*(x + y) + 4*(x - y)*y*(x + y));
					dBidxj[2][1] += G*(4*x*(x - y)*y + 4*x*(x - y)*(x + y) - 4*x*y*(x + y));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-3){
				B[0] += -(G*x*y*(3*std::pow(x,2) + std::pow(y,2) - 12*std::pow(z,2)));
				B[1] += (G*(-3*std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) + 24*(x - y)*(x + y)*std::pow(z,2)))/4.;
				B[2] += -4*G*y*(-3*std::pow(x,2) + std::pow(y,2))*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-6*std::pow(x,2)*y - y*(3*std::pow(x,2) + std::pow(y,2) - 12*std::pow(z,2)));
					dBidxj[0][1] += G*(-2*x*std::pow(y,2) - x*(3*std::pow(x,2) + std::pow(y,2) - 12*std::pow(z,2)));
					dBidxj[0][2] += 24*G*x*y*z;
					dBidxj[1][0] += (G*(-12*std::pow(x,3) - 12*x*std::pow(y,2) + 24*(x - y)*std::pow(z,2) + 24*(x + y)*std::pow(z,2)))/4.;
					dBidxj[1][1] += (G*(-12*std::pow(x,2)*y + 20*std::pow(y,3) + 24*(x - y)*std::pow(z,2) - 24*(x + y)*std::pow(z,2)))/4.;
					dBidxj[1][2] += 12*G*(x - y)*(x + y)*z;
					dBidxj[2][0] += 24*G*x*y*z;
					dBidxj[2][1] += G*(-8*std::pow(y,2)*z - 4*(-3*std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[2][2] += -4*G*y*(-3*std::pow(x,2) + std::pow(y,2));
				}
			}
			else if (m==-2){
				B[0] += -2*G*y*z*(3*std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2));
				B[1] += -2*G*x*z*(std::pow(x,2) + 3*std::pow(y,2) - 2*std::pow(z,2));
				B[2] += -2*G*x*y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += -12*G*x*y*z;
					dBidxj[0][1] += G*(-4*std::pow(y,2)*z - 2*z*(3*std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[0][2] += G*(8*y*std::pow(z,2) - 2*y*(3*std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[1][0] += G*(-4*std::pow(x,2)*z - 2*z*(std::pow(x,2) + 3*std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[1][1] += -12*G*x*y*z;
					dBidxj[1][2] += G*(8*x*std::pow(z,2) - 2*x*(std::pow(x,2) + 3*std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][0] += G*(-4*std::pow(x,2)*y - 2*y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)));
					dBidxj[2][1] += G*(-4*x*std::pow(y,2) - 2*x*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)));
					dBidxj[2][2] += 24*G*x*y*z;
				}
			}
			else if (m==-1){
				B[0] += (G*x*y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.;
				B[1] += (G*(std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) - 12*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.;
				B[2] += G*(-3*y*(std::pow(x,2) + std::pow(y,2))*z + 4*y*std::pow(z,3));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(std::pow(x,2)*y + (y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[0][1] += G*(x*std::pow(y,2) + (x*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[0][2] += -6*G*x*y*z;
					dBidxj[1][0] += (G*(4*std::pow(x,3) + 12*x*std::pow(y,2) - 24*x*std::pow(z,2)))/8.;
					dBidxj[1][1] += (G*(12*std::pow(x,2)*y + 20*std::pow(y,3) - 72*y*std::pow(z,2)))/8.;
					dBidxj[1][2] += (G*(-24*(std::pow(x,2) + 3*std::pow(y,2))*z + 32*std::pow(z,3)))/8.;
					dBidxj[2][0] += -6*G*x*y*z;
					dBidxj[2][1] += G*(-6*std::pow(y,2)*z - 3*(std::pow(x,2) + std::pow(y,2))*z + 4*std::pow(z,3));
					dBidxj[2][2] += G*(-3*y*(std::pow(x,2) + std::pow(y,2)) + 12*y*std::pow(z,2));
				}
			}
			else if (m==0){
				B[0] += G*((3*x*(std::pow(x,2) + std::pow(y,2))*z)/2. - 2*x*std::pow(z,3));
				B[1] += G*((3*y*(std::pow(x,2) + std::pow(y,2))*z)/2. - 2*y*std::pow(z,3));
				B[2] += G*((3*std::pow(std::pow(x,2) + std::pow(y,2),2))/8. - 3*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + std::pow(z,4));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(3*std::pow(x,2)*z + (3*(std::pow(x,2) + std::pow(y,2))*z)/2. - 2*std::pow(z,3));
					dBidxj[0][1] += 3*G*x*y*z;
					dBidxj[0][2] += G*((3*x*(std::pow(x,2) + std::pow(y,2)))/2. - 6*x*std::pow(z,2));
					dBidxj[1][0] += 3*G*x*y*z;
					dBidxj[1][1] += G*(3*std::pow(y,2)*z + (3*(std::pow(x,2) + std::pow(y,2))*z)/2. - 2*std::pow(z,3));
					dBidxj[1][2] += G*((3*y*(std::pow(x,2) + std::pow(y,2)))/2. - 6*y*std::pow(z,2));
					dBidxj[2][0] += G*((3*x*(std::pow(x,2) + std::pow(y,2)))/2. - 6*x*std::pow(z,2));
					dBidxj[2][1] += G*((3*y*(std::pow(x,2) + std::pow(y,2)))/2. - 6*y*std::pow(z,2));
					dBidxj[2][2] += G*(-6*(std::pow(x,2) + std::pow(y,2))*z + 4*std::pow(z,3));
				}
			}
			else if (m==1){
				B[0] += (G*(5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4) - 12*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.;
				B[1] += (G*x*y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.;
				B[2] += G*(-3*x*(std::pow(x,2) + std::pow(y,2))*z + 4*x*std::pow(z,3));
				if (dBidxj != nullptr){
					dBidxj[0][0] += (G*(20*std::pow(x,3) + 12*x*std::pow(y,2) - 72*x*std::pow(z,2)))/8.;
					dBidxj[0][1] += (G*(12*std::pow(x,2)*y + 4*std::pow(y,3) - 24*y*std::pow(z,2)))/8.;
					dBidxj[0][2] += (G*(-24*(3*std::pow(x,2) + std::pow(y,2))*z + 32*std::pow(z,3)))/8.;
					dBidxj[1][0] += G*(std::pow(x,2)*y + (y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[1][1] += G*(x*std::pow(y,2) + (x*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[1][2] += -6*G*x*y*z;
					dBidxj[2][0] += G*(-6*std::pow(x,2)*z - 3*(std::pow(x,2) + std::pow(y,2))*z + 4*std::pow(z,3));
					dBidxj[2][1] += -6*G*x*y*z;
					dBidxj[2][2] += G*(-3*x*(std::pow(x,2) + std::pow(y,2)) + 12*x*std::pow(z,2));
				}
			}
			else if (m==2){
				B[0] += -4*G*x*(x - z)*z*(x + z);
				B[1] += 4*G*y*(y - z)*z*(y + z);
				B[2] += G*(-std::pow(x,4) + std::pow(y,4) + 6*(x - y)*(x + y)*std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-4*x*(x - z)*z - 4*x*z*(x + z) - 4*(x - z)*z*(x + z));
					dBidxj[0][1] += 0;
					dBidxj[0][2] += G*(-4*x*(x - z)*z - 4*x*(x - z)*(x + z) + 4*x*z*(x + z));
					dBidxj[1][0] += 0;
					dBidxj[1][1] += G*(4*y*(y - z)*z + 4*y*z*(y + z) + 4*(y - z)*z*(y + z));
					dBidxj[1][2] += G*(4*y*(y - z)*z + 4*y*(y - z)*(y + z) - 4*y*z*(y + z));
					dBidxj[2][0] += G*(-4*std::pow(x,3) + 6*(x - y)*std::pow(z,2) + 6*(x + y)*std::pow(z,2));
					dBidxj[2][1] += G*(4*std::pow(y,3) + 6*(x - y)*std::pow(z,2) - 6*(x + y)*std::pow(z,2));
					dBidxj[2][2] += 12*G*(x - y)*(x + y)*z;
				}
			}
			else if (m==3){
				B[0] += (G*(-5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 3*std::pow(y,4) + 24*(x - y)*(x + y)*std::pow(z,2)))/4.;
				B[1] += G*x*y*(std::pow(x,2) + 3*(std::pow(y,2) - 4*std::pow(z,2)));
				B[2] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (G*(-20*std::pow(x,3) + 12*x*std::pow(y,2) + 24*(x - y)*std::pow(z,2) + 24*(x + y)*std::pow(z,2)))/4.;
					dBidxj[0][1] += (G*(12*std::pow(x,2)*y + 12*std::pow(y,3) + 24*(x - y)*std::pow(z,2) - 24*(x + y)*std::pow(z,2)))/4.;
					dBidxj[0][2] += 12*G*(x - y)*(x + y)*z;
					dBidxj[1][0] += G*(2*std::pow(x,2)*y + y*(std::pow(x,2) + 3*(std::pow(y,2) - 4*std::pow(z,2))));
					dBidxj[1][1] += G*(6*x*std::pow(y,2) + x*(std::pow(x,2) + 3*(std::pow(y,2) - 4*std::pow(z,2))));
					dBidxj[1][2] += -24*G*x*y*z;
					dBidxj[2][0] += G*(8*std::pow(x,2)*z + 4*(std::pow(x,2) - 3*std::pow(y,2))*z);
					dBidxj[2][1] += -24*G*x*y*z;
					dBidxj[2][2] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2));
				}
			}
			else if (m==4){
				B[0] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
				B[1] += 4*G*y*(-3*std::pow(x,2) + std::pow(y,2))*z;
				B[2] += G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(8*std::pow(x,2)*z + 4*(std::pow(x,2) - 3*std::pow(y,2))*z);
					dBidxj[0][1] += -24*G*x*y*z;
					dBidxj[0][2] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[1][0] += -24*G*x*y*z;
					dBidxj[1][1] += G*(8*std::pow(y,2)*z + 4*(-3*std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[1][2] += 4*G*y*(-3*std::pow(x,2) + std::pow(y,2));
					dBidxj[2][0] += G*(4*std::pow(x,3) - 12*x*std::pow(y,2));
					dBidxj[2][1] += G*(-12*std::pow(x,2)*y + 4*std::pow(y,3));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==5){
				B[0] += G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
				B[1] += 4*G*x*y*(-std::pow(x,2) + std::pow(y,2));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(4*std::pow(x,3) - 12*x*std::pow(y,2));
					dBidxj[0][1] += G*(-12*std::pow(x,2)*y + 4*std::pow(y,3));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G*(-8*std::pow(x,2)*y + 4*y*(-std::pow(x,2) + std::pow(y,2)));
					dBidxj[1][1] += G*(8*x*std::pow(y,2) + 4*x*(-std::pow(x,2) + std::pow(y,2)));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else if (l==5){
			if (m==-6){
				B[0] += G*(5*std::pow(x,4)*y - 10*std::pow(x,2)*std::pow(y,3) + std::pow(y,5));
				B[1] += G*(std::pow(x,5) - 10*std::pow(x,3)*std::pow(y,2) + 5*x*std::pow(y,4));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(20*std::pow(x,3)*y - 20*x*std::pow(y,3));
					dBidxj[0][1] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[1][1] += G*(-20*std::pow(x,3)*y + 20*x*std::pow(y,3));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-5){
				B[0] += 20*G*x*(x - y)*y*(x + y)*z;
				B[1] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4))*z;
				B[2] += G*(5*std::pow(x,4)*y - 10*std::pow(x,2)*std::pow(y,3) + std::pow(y,5));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(20*x*(x - y)*y*z + 20*x*y*(x + y)*z + 20*(x - y)*y*(x + y)*z);
					dBidxj[0][1] += G*(20*x*(x - y)*y*z + 20*x*(x - y)*(x + y)*z - 20*x*y*(x + y)*z);
					dBidxj[0][2] += 20*G*x*(x - y)*y*(x + y);
					dBidxj[1][0] += 5*G*(4*std::pow(x,3) - 12*x*std::pow(y,2))*z;
					dBidxj[1][1] += 5*G*(-12*std::pow(x,2)*y + 4*std::pow(y,3))*z;
					dBidxj[1][2] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
					dBidxj[2][0] += G*(20*std::pow(x,3)*y - 20*x*std::pow(y,3));
					dBidxj[2][1] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-4){
				B[0] += G*(-5*std::pow(x,4)*y + std::pow(y,5) + 30*std::pow(x,2)*y*std::pow(z,2) - 10*std::pow(y,3)*std::pow(z,2));
				B[1] += G*x*(-std::pow(x,4) + 5*std::pow(y,4) + 10*(std::pow(x,2) - 3*std::pow(y,2))*std::pow(z,2));
				B[2] += 20*G*x*(x - y)*y*(x + y)*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-20*std::pow(x,3)*y + 60*x*y*std::pow(z,2));
					dBidxj[0][1] += G*(-5*std::pow(x,4) + 5*std::pow(y,4) + 30*std::pow(x,2)*std::pow(z,2) - 30*std::pow(y,2)*std::pow(z,2));
					dBidxj[0][2] += G*(60*std::pow(x,2)*y*z - 20*std::pow(y,3)*z);
					dBidxj[1][0] += G*(-std::pow(x,4) + 5*std::pow(y,4) + 10*(std::pow(x,2) - 3*std::pow(y,2))*std::pow(z,2) + x*(-4*std::pow(x,3) + 20*x*std::pow(z,2)));
					dBidxj[1][1] += G*x*(20*std::pow(y,3) - 60*y*std::pow(z,2));
					dBidxj[1][2] += 20*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
					dBidxj[2][0] += G*(20*x*(x - y)*y*z + 20*x*y*(x + y)*z + 20*(x - y)*y*(x + y)*z);
					dBidxj[2][1] += G*(20*x*(x - y)*y*z + 20*x*(x - y)*(x + y)*z - 20*x*y*(x + y)*z);
					dBidxj[2][2] += 20*G*x*(x - y)*y*(x + y);
				}
			}
			else if (m==-3){
				B[0] += -5*G*x*y*z*(3*std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2));
				B[1] += (5*G*z*(-3*std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) + 8*(x - y)*(x + y)*std::pow(z,2)))/4.;
				B[2] += (5*G*y*(-3*std::pow(x,2) + std::pow(y,2))*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/4.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-30*std::pow(x,2)*y*z - 5*y*z*(3*std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[0][1] += G*(-10*x*std::pow(y,2)*z - 5*x*z*(3*std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[0][2] += G*(40*x*y*std::pow(z,2) - 5*x*y*(3*std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[1][0] += (5*G*z*(-12*std::pow(x,3) - 12*x*std::pow(y,2) + 8*(x - y)*std::pow(z,2) + 8*(x + y)*std::pow(z,2)))/4.;
					dBidxj[1][1] += (5*G*z*(-12*std::pow(x,2)*y + 20*std::pow(y,3) + 8*(x - y)*std::pow(z,2) - 8*(x + y)*std::pow(z,2)))/4.;
					dBidxj[1][2] += G*(20*(x - y)*(x + y)*std::pow(z,2) + (5*(-3*std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) + 8*(x - y)*(x + y)*std::pow(z,2)))/4.);
					dBidxj[2][0] += G*((5*x*y*(-3*std::pow(x,2) + std::pow(y,2)))/2. - (15*x*y*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/2.);
					dBidxj[2][1] += G*((5*std::pow(y,2)*(-3*std::pow(x,2) + std::pow(y,2)))/2. + (5*std::pow(y,2)*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/2. + (5*(-3*std::pow(x,2) + std::pow(y,2))*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/4.);
					dBidxj[2][2] += -20*G*y*(-3*std::pow(x,2) + std::pow(y,2))*z;
				}
			}
			else if (m==-2){
				B[0] += (5*G*y*(5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4) - 16*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 16*std::pow(z,4)))/16.;
				B[1] += (5*G*x*(std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) - 16*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,2) + 16*std::pow(z,4)))/16.;
				B[2] += -10*G*x*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += (5*G*y*(20*std::pow(x,3) + 12*x*std::pow(y,2) - 96*x*std::pow(z,2)))/16.;
					dBidxj[0][1] += G*((5*y*(12*std::pow(x,2)*y + 4*std::pow(y,3) - 32*y*std::pow(z,2)))/16. + (5*(5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4) - 16*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 16*std::pow(z,4)))/16.);
					dBidxj[0][2] += (5*G*y*(-32*(3*std::pow(x,2) + std::pow(y,2))*z + 64*std::pow(z,3)))/16.;
					dBidxj[1][0] += G*((5*x*(4*std::pow(x,3) + 12*x*std::pow(y,2) - 32*x*std::pow(z,2)))/16. + (5*(std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) - 16*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,2) + 16*std::pow(z,4)))/16.);
					dBidxj[1][1] += (5*G*x*(12*std::pow(x,2)*y + 20*std::pow(y,3) - 96*y*std::pow(z,2)))/16.;
					dBidxj[1][2] += (5*G*x*(-32*(std::pow(x,2) + 3*std::pow(y,2))*z + 64*std::pow(z,3)))/16.;
					dBidxj[2][0] += G*(-20*std::pow(x,2)*y*z - 10*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][1] += G*(-20*x*std::pow(y,2)*z - 10*x*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][2] += G*(40*x*y*std::pow(z,2) - 10*x*y*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
				}
			}
			else if (m==-1){
				B[0] += (5*G*x*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.;
				B[1] += G*((5*(std::pow(x,2) + std::pow(y,2))*(std::pow(x,2) + 5*std::pow(y,2))*z)/8. - (5*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,3))/2. + std::pow(z,5));
				B[2] += (5*G*y*(std::pow(std::pow(x,2) + std::pow(y,2),2) - 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(5*std::pow(x,2)*y*z + (5*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[0][1] += G*(5*x*std::pow(y,2)*z + (5*x*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[0][2] += G*(-10*x*y*std::pow(z,2) + (5*x*y*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[1][0] += G*((5*x*(std::pow(x,2) + std::pow(y,2))*z)/4. + (5*x*(std::pow(x,2) + 5*std::pow(y,2))*z)/4. - 5*x*std::pow(z,3));
					dBidxj[1][1] += G*((25*y*(std::pow(x,2) + std::pow(y,2))*z)/4. + (5*y*(std::pow(x,2) + 5*std::pow(y,2))*z)/4. - 15*y*std::pow(z,3));
					dBidxj[1][2] += G*((5*(std::pow(x,2) + std::pow(y,2))*(std::pow(x,2) + 5*std::pow(y,2)))/8. - (15*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,2))/2. + 5*std::pow(z,4));
					dBidxj[2][0] += (5*G*y*(4*x*(std::pow(x,2) + std::pow(y,2)) - 24*x*std::pow(z,2)))/8.;
					dBidxj[2][1] += G*((5*y*(4*y*(std::pow(x,2) + std::pow(y,2)) - 24*y*std::pow(z,2)))/8. + (5*(std::pow(std::pow(x,2) + std::pow(y,2),2) - 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.);
					dBidxj[2][2] += (5*G*y*(-24*(std::pow(x,2) + std::pow(y,2))*z + 32*std::pow(z,3)))/8.;
				}
			}
			else if (m==0){
				B[0] += (5*G*x*(-std::pow(std::pow(x,2) + std::pow(y,2),2) + 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) - 8*std::pow(z,4)))/16.;
				B[1] += (5*G*y*(-std::pow(std::pow(x,2) + std::pow(y,2),2) + 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) - 8*std::pow(z,4)))/16.;
				B[2] += G*((15*std::pow(std::pow(x,2) + std::pow(y,2),2)*z)/8. - 5*(std::pow(x,2) + std::pow(y,2))*std::pow(z,3) + std::pow(z,5));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((5*x*(-4*x*(std::pow(x,2) + std::pow(y,2)) + 24*x*std::pow(z,2)))/16. + (5*(-std::pow(std::pow(x,2) + std::pow(y,2),2) + 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) - 8*std::pow(z,4)))/16.);
					dBidxj[0][1] += (5*G*x*(-4*y*(std::pow(x,2) + std::pow(y,2)) + 24*y*std::pow(z,2)))/16.;
					dBidxj[0][2] += (5*G*x*(24*(std::pow(x,2) + std::pow(y,2))*z - 32*std::pow(z,3)))/16.;
					dBidxj[1][0] += (5*G*y*(-4*x*(std::pow(x,2) + std::pow(y,2)) + 24*x*std::pow(z,2)))/16.;
					dBidxj[1][1] += G*((5*y*(-4*y*(std::pow(x,2) + std::pow(y,2)) + 24*y*std::pow(z,2)))/16. + (5*(-std::pow(std::pow(x,2) + std::pow(y,2),2) + 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) - 8*std::pow(z,4)))/16.);
					dBidxj[1][2] += (5*G*y*(24*(std::pow(x,2) + std::pow(y,2))*z - 32*std::pow(z,3)))/16.;
					dBidxj[2][0] += G*((15*x*(std::pow(x,2) + std::pow(y,2))*z)/2. - 10*x*std::pow(z,3));
					dBidxj[2][1] += G*((15*y*(std::pow(x,2) + std::pow(y,2))*z)/2. - 10*y*std::pow(z,3));
					dBidxj[2][2] += G*((15*std::pow(std::pow(x,2) + std::pow(y,2),2))/8. - 15*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 5*std::pow(z,4));
				}
			}
			else if (m==1){
				B[0] += G*((5*(std::pow(x,2) + std::pow(y,2))*(5*std::pow(x,2) + std::pow(y,2))*z)/8. - (5*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,3))/2. + std::pow(z,5));
				B[1] += (5*G*x*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.;
				B[2] += (5*G*x*(std::pow(std::pow(x,2) + std::pow(y,2),2) - 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((25*x*(std::pow(x,2) + std::pow(y,2))*z)/4. + (5*x*(5*std::pow(x,2) + std::pow(y,2))*z)/4. - 15*x*std::pow(z,3));
					dBidxj[0][1] += G*((5*y*(std::pow(x,2) + std::pow(y,2))*z)/4. + (5*y*(5*std::pow(x,2) + std::pow(y,2))*z)/4. - 5*y*std::pow(z,3));
					dBidxj[0][2] += G*((5*(std::pow(x,2) + std::pow(y,2))*(5*std::pow(x,2) + std::pow(y,2)))/8. - (15*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,2))/2. + 5*std::pow(z,4));
					dBidxj[1][0] += G*(5*std::pow(x,2)*y*z + (5*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[1][1] += G*(5*x*std::pow(y,2)*z + (5*x*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[1][2] += G*(-10*x*y*std::pow(z,2) + (5*x*y*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[2][0] += G*((5*x*(4*x*(std::pow(x,2) + std::pow(y,2)) - 24*x*std::pow(z,2)))/8. + (5*(std::pow(std::pow(x,2) + std::pow(y,2),2) - 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.);
					dBidxj[2][1] += (5*G*x*(4*y*(std::pow(x,2) + std::pow(y,2)) - 24*y*std::pow(z,2)))/8.;
					dBidxj[2][2] += (5*G*x*(-24*(std::pow(x,2) + std::pow(y,2))*z + 32*std::pow(z,3)))/8.;
				}
			}
			else if (m==2){
				B[0] += (5*G*x*(3*std::pow(x,4) - std::pow(y,4) + 16*std::pow(z,4) + 2*std::pow(x,2)*(std::pow(y,2) - 16*std::pow(z,2))))/16.;
				B[1] += (5*G*y*(std::pow(x,4) - 2*std::pow(x,2)*std::pow(y,2) - 3*std::pow(y,4) + 32*std::pow(y,2)*std::pow(z,2) - 16*std::pow(z,4)))/16.;
				B[2] += -5*G*(x - y)*(x + y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((5*x*(12*std::pow(x,3) + 4*x*(std::pow(y,2) - 16*std::pow(z,2))))/16. + (5*(3*std::pow(x,4) - std::pow(y,4) + 16*std::pow(z,4) + 2*std::pow(x,2)*(std::pow(y,2) - 16*std::pow(z,2))))/16.);
					dBidxj[0][1] += (5*G*x*(4*std::pow(x,2)*y - 4*std::pow(y,3)))/16.;
					dBidxj[0][2] += (5*G*x*(-64*std::pow(x,2)*z + 64*std::pow(z,3)))/16.;
					dBidxj[1][0] += (5*G*y*(4*std::pow(x,3) - 4*x*std::pow(y,2)))/16.;
					dBidxj[1][1] += G*((5*y*(-4*std::pow(x,2)*y - 12*std::pow(y,3) + 64*y*std::pow(z,2)))/16. + (5*(std::pow(x,4) - 2*std::pow(x,2)*std::pow(y,2) - 3*std::pow(y,4) + 32*std::pow(y,2)*std::pow(z,2) - 16*std::pow(z,4)))/16.);
					dBidxj[1][2] += (5*G*y*(64*std::pow(y,2)*z - 64*std::pow(z,3)))/16.;
					dBidxj[2][0] += G*(-10*x*(x - y)*(x + y)*z - 5*(x - y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)) - 5*(x + y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][1] += G*(-10*(x - y)*y*(x + y)*z - 5*(x - y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)) + 5*(x + y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][2] += G*(20*(x - y)*(x + y)*std::pow(z,2) - 5*(x - y)*(x + y)*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
				}
			}
			else if (m==3){
				B[0] += (5*G*z*(-5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 3*std::pow(y,4) + 8*(x - y)*(x + y)*std::pow(z,2)))/4.;
				B[1] += 5*G*x*y*z*(std::pow(x,2) + 3*std::pow(y,2) - 4*std::pow(z,2));
				B[2] += (-5*G*x*(std::pow(x,2) - 3*std::pow(y,2))*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/4.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (5*G*z*(-20*std::pow(x,3) + 12*x*std::pow(y,2) + 8*(x - y)*std::pow(z,2) + 8*(x + y)*std::pow(z,2)))/4.;
					dBidxj[0][1] += (5*G*z*(12*std::pow(x,2)*y + 12*std::pow(y,3) + 8*(x - y)*std::pow(z,2) - 8*(x + y)*std::pow(z,2)))/4.;
					dBidxj[0][2] += G*(20*(x - y)*(x + y)*std::pow(z,2) + (5*(-5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 3*std::pow(y,4) + 8*(x - y)*(x + y)*std::pow(z,2)))/4.);
					dBidxj[1][0] += G*(10*std::pow(x,2)*y*z + 5*y*z*(std::pow(x,2) + 3*std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[1][1] += G*(30*x*std::pow(y,2)*z + 5*x*z*(std::pow(x,2) + 3*std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[1][2] += G*(-40*x*y*std::pow(z,2) + 5*x*y*(std::pow(x,2) + 3*std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[2][0] += G*((-5*std::pow(x,2)*(std::pow(x,2) - 3*std::pow(y,2)))/2. - (5*std::pow(x,2)*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/2. - (5*(std::pow(x,2) - 3*std::pow(y,2))*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/4.);
					dBidxj[2][1] += G*((-5*x*y*(std::pow(x,2) - 3*std::pow(y,2)))/2. + (15*x*y*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/2.);
					dBidxj[2][2] += 20*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
				}
			}
			else if (m==4){
				B[0] += G*((-3*std::pow(x,5))/2. + 5*std::pow(x,3)*(std::pow(y,2) + 2*std::pow(z,2)) + (5*x*(std::pow(y,4) - 12*std::pow(y,2)*std::pow(z,2)))/2.);
				B[1] += (G*y*(5*std::pow(x,4) - 3*std::pow(y,4) + 20*std::pow(y,2)*std::pow(z,2) + 10*std::pow(x,2)*(std::pow(y,2) - 6*std::pow(z,2))))/2.;
				B[2] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4))*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((-15*std::pow(x,4))/2. + 15*std::pow(x,2)*(std::pow(y,2) + 2*std::pow(z,2)) + (5*(std::pow(y,4) - 12*std::pow(y,2)*std::pow(z,2)))/2.);
					dBidxj[0][1] += G*(10*std::pow(x,3)*y + (5*x*(4*std::pow(y,3) - 24*y*std::pow(z,2)))/2.);
					dBidxj[0][2] += G*(20*std::pow(x,3)*z - 60*x*std::pow(y,2)*z);
					dBidxj[1][0] += (G*y*(20*std::pow(x,3) + 20*x*(std::pow(y,2) - 6*std::pow(z,2))))/2.;
					dBidxj[1][1] += G*((y*(20*std::pow(x,2)*y - 12*std::pow(y,3) + 40*y*std::pow(z,2)))/2. + (5*std::pow(x,4) - 3*std::pow(y,4) + 20*std::pow(y,2)*std::pow(z,2) + 10*std::pow(x,2)*(std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[1][2] += (G*y*(-120*std::pow(x,2)*z + 40*std::pow(y,2)*z))/2.;
					dBidxj[2][0] += 5*G*(4*std::pow(x,3) - 12*x*std::pow(y,2))*z;
					dBidxj[2][1] += 5*G*(-12*std::pow(x,2)*y + 4*std::pow(y,3))*z;
					dBidxj[2][2] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
				}
			}
			else if (m==5){
				B[0] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4))*z;
				B[1] += 20*G*x*y*(-std::pow(x,2) + std::pow(y,2))*z;
				B[2] += G*(std::pow(x,5) - 10*std::pow(x,3)*std::pow(y,2) + 5*x*std::pow(y,4));
				if (dBidxj != nullptr){
					dBidxj[0][0] += 5*G*(4*std::pow(x,3) - 12*x*std::pow(y,2))*z;
					dBidxj[0][1] += 5*G*(-12*std::pow(x,2)*y + 4*std::pow(y,3))*z;
					dBidxj[0][2] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
					dBidxj[1][0] += G*(-40*std::pow(x,2)*y*z + 20*y*(-std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[1][1] += G*(40*x*std::pow(y,2)*z + 20*x*(-std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[1][2] += 20*G*x*y*(-std::pow(x,2) + std::pow(y,2));
					dBidxj[2][0] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[2][1] += G*(-20*std::pow(x,3)*y + 20*x*std::pow(y,3));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==6){
				B[0] += G*(std::pow(x,5) - 10*std::pow(x,3)*std::pow(y,2) + 5*x*std::pow(y,4));
				B[1] += -(G*y*(5*std::pow(x,4) - 10*std::pow(x,2)*std::pow(y,2) + std::pow(y,4)));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[0][1] += G*(-20*std::pow(x,3)*y + 20*x*std::pow(y,3));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += -(G*y*(20*std::pow(x,3) - 20*x*std::pow(y,2)));
					dBidxj[1][1] += G*(-5*std::pow(x,4) + 10*std::pow(x,2)*std::pow(y,2) - std::pow(y,4) - y*(-20*std::pow(x,2)*y + 4*std::pow(y,3)));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else{
			throw std::runtime_error("Tried to evaluate HarmonicExpansionBField with invalid parameters! Aborting...");
		}
	}

}

void HarmonicExpandedBField::BField_old(const double _x, const double _y, const double _z, const double t, double B[3], double dBidxj[3][3]) const{

	// Updating the x, y, z values with the given offset values
	double x = _x + xoff;
	double y = _y + yoff;
	double z = _z + zoff;

	/* 
	Information about Calculating the Harmonic Polynomial Expansion

	The calculations below are hard-coded using the cartesian form of the 
	harmonic polynomial expansion. Alternatively, this can be carried out 
	in an iterative fashion using the BOOST library for "Legendre and 
	associated polynomials":
	
	boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sf_poly/legendre.html 

	This was not chosen for the implementation here because it was believed
	that this hard-coded representation displayed the physical form of the 
	functions more explicitly. Perhaps more importantly, this form is much
	easier to debug. 

	If in future, simulations wish to explore harmonic expansions above third 
	order, returning to an implementation using BOOST's legendre library may
	be preferrable. 
	*/

	std::vector<double> G(24, 0.);
	for (auto glm: Glm){
		int l = std::get<0>(glm);
		int m = std::get<1>(glm);
		double g = std::get<2>(glm);
		G[l*(l + 2) + (m + l + 1)] = g;
	}

	// Calculating B_x
	B[0] = 	  G[2] 	\
			+ G[3]  * (y) \
			+ G[5]  * (-x / 2) \
			+ G[6]  * (z) \
			+ G[7]  * (x) \
			+ G[8]  * (2 * x * y) \
			+ G[9]  * (2 * y * z) \
			+ G[10] * (-x * y / 2) \
			+ G[11] * (-x * z) \
			+ G[12] * (-(3 * std::pow(x,2) + std::pow(y,2) - 4 * std::pow(z,2)) / 4) \
			+ G[13] * (2 * x * z) \
			+ G[14] * ((std::pow(x,2) - std::pow(y,2))) \
			+ G[15] * ((3 * std::pow(x,2) * y - std::pow(y,3))) \
			+ G[16] * (6 * x * y * z) \
			+ G[17] * (-(3 * std::pow(x,2) * y + std::pow(y,3) - 6 * y * std::pow(z,2)) / 2) \
			+ G[18] * (-(3. / 2) * (x * y * z)) \
			+ G[19] * ((3. / 8) * (std::pow(x,3) + x * std::pow(y,2) - 4 * x * std::pow(z,2))) \
			+ G[20] * ((-1. / 4) * (9 * std::pow(x,2) * z + 3 * std::pow(y,2) * z - 4 * std::pow(z,3))) \
			+ G[21] * (-std::pow(x,3) + 3 * x * std::pow(z,2)) \
			+ G[22] * (3 * (std::pow(x,2) * z - std::pow(y,2) * z)) \
			+ G[23] * (std::pow(x,3) - 3 * x * std::pow(y,2));
	
	// Calculating B_y
	B[1] =	  G[0] 	\
			+ G[3]  * (x) \
			+ G[4]  * (z) \
			+ G[5]  * (-y / 2) \
			+ G[7]  * (-y) \
			+ G[8]  * (std::pow(x,2) - std::pow(y,2)) \
			+ G[9]  * (2 * x * z) \
			+ G[10] * ((std::pow(x,2) + 3 * std::pow(y,2) - 4 * std::pow(z,2)) / -4) \
			+ G[11] * (-y * z) \
			+ G[12] * (-x * y / 2) \
			+ G[13] * (-2 * y * z) \
			+ G[14] * (-2 * x * y) \
			+ G[15] * (std::pow(x,3) - 3 * x * std::pow(y,2)) \
			+ G[16] * (3 * (std::pow(x,2) * z - std::pow(y,2) * z)) \
			+ G[17] * (-(std::pow(x,3) + 3 * x * std::pow(y,2) - 6 * x * std::pow(z,2)) / 2) \
			+ G[18] * ( (-1. / 4) * (3 * std::pow(x,2) * z + 9 * std::pow(y,2) * z - 4 * std::pow(z,3))) \
			+ G[19] * ((3. / 8) * (std::pow(x,2) * y + std::pow(y,3) - 4 * y * std::pow(z,2))) \
			+ G[20] * ((-3. / 2) * x * y * z) \
			+ G[21] * (-3 * y * std::pow(z,2) + std::pow(y,3)) \
			+ G[22] * (-6 * x * y * z) \
			+ G[23] * (-3 * std::pow(x,2) * y + std::pow(y,3));

	// Calculating B_z
	B[2] =	  G[1] 	\
			+ G[4]  * (y) \
			+ G[5]  * (z) \
			+ G[6]  * (x) \
			+ G[9]  * (2 * x * y) \
			+ G[10] * (2 * y * z) \
			+ G[11] * (std::pow(z,2) - (1. / 2) * (std::pow(x,2) + std::pow(y,2))) \
			+ G[12] * (2 * x * z) \
			+ G[13] * (std::pow(x,2) - std::pow(y,2)) \
			+ G[16] * (3 * std::pow(x,2) * y - std::pow(y,3))\
			+ G[17] * (6 * x * y * z)  \
			+ G[18] * (3 * y * std::pow(z,2) - (3./4) * (std::pow(x,2) * y + std::pow(y,3))) \
			+ G[19] * (std::pow(z,3) - (3. / 2) * z * (std::pow(x,2) + std::pow(y,2))) \
			+ G[20] * (3 * x * std::pow(z,2) - (3./4) * (std::pow(x,3) + x * std::pow(y,2))) \
			+ G[21] * (3 * (std::pow(x,2) * z - std::pow(y,2) * z)) \
			+ G[22] * (std::pow(x,3) - 3 * x * std::pow(y,2));


	if (dBidxj != nullptr){

		// Calculating dBxdx
		dBidxj[0][0] = -G[5]/2 + G[7] + 2*G[8]*y - G[10]*y/2 - G[11]*z - \
					3*G[12]*x/2 + 2*G[13]*z + 2*G[14]*x + 6*G[15]*x*y + \
					6*G[16]*y*z - 3*G[17]*x*y - 1.5*G[18]*y*z + \
					G[19]*(1.125*std::pow(x,2) + 0.375*std::pow(y,2) - 1.5*std::pow(z,2)) - \
					4.5*G[20]*x*z + G[21]*(-3*std::pow(x,2) + 3*std::pow(z,2)) + \
					6*G[22]*x*z + G[23]*(3*std::pow(x,2) - 3*std::pow(y,2));

		// Calculating dBxdy
		dBidxj[0][1] = G[3] + 2*G[8]*x + 2*G[9]*z - G[10]*x/2 - G[12]*y/2 - \
					2*G[14]*y + G[15]*(3*std::pow(x,2) - 3*std::pow(y,2)) + 6*G[16]*x*z+\
					G[17]*(-3*std::pow(x,2)/2 - 3*std::pow(y,2)/2 + 3*std::pow(z,2)) - \
					1.5*G[18]*x*z + 0.75*G[19]*x*y - 1.5*G[20]*y*z - \
					6*G[22]*y*z - 6*G[23]*x*y;

		// Calculating dBxdz
		dBidxj[0][2] = G[6] + 2*G[9]*y - G[11]*x + 2*G[12]*z + 2*G[13]*x + \
					6*G[16]*x*y + 6*G[17]*y*z - 1.5*G[18]*x*y - 3.0*G[19]*x*z+\
					G[20]*(-2.25*std::pow(x,2) - 0.75*std::pow(y,2) + 3.0*std::pow(z,2)) + \
					6*G[21]*x*z + G[22]*(3*std::pow(x,2) - 3*std::pow(y,2));

		// Calculating dBydx
		dBidxj[1][0] = G[3] + 2*G[8]*x + 2*G[9]*z - G[10]*x/2 - G[12]*y/2 - \
					2*G[14]*y + G[15]*(3*std::pow(x,2) - 3*std::pow(y,2)) + 6*G[16]*x*z+\
					G[17]*(-3*std::pow(x,2)/2 - 3*std::pow(y,2)/2 + 3*std::pow(z,2)) - \
					1.5*G[18]*x*z + 0.75*G[19]*x*y - 1.5*G[20]*y*z - \
					6*G[22]*y*z - 6*G[23]*x*y;

		// Calculating dBydy
		dBidxj[1][1] = -G[5]/2 - G[7] - 2*G[8]*y - 3*G[10]*y/2 - G[11]*z - \
					G[12]*x/2 - 2*G[13]*z - 2*G[14]*x - 6*G[15]*x*y - \
					6*G[16]*y*z - 3*G[17]*x*y - 4.5*G[18]*y*z + \
					G[19]*(0.375*std::pow(x,2) + 1.125*std::pow(y,2) - 1.5*std::pow(z,2)) - \
					1.5*G[20]*x*z + G[21]*(3*std::pow(y,2) - 3*std::pow(z,2)) - \
					6*G[22]*x*z + G[23]*(-3*std::pow(x,2) + 3*std::pow(y,2));

		// Calculating dBydz
		dBidxj[1][2] = G[4] + 2*G[9]*x + 2*G[10]*z - G[11]*y - 2*G[13]*y + \
					G[16]*(3*std::pow(x,2) - 3*std::pow(y,2)) + 6*G[17]*x*z + \
					G[18]*(-0.75*std::pow(x,2) - 2.25*std::pow(y,2) + 3.0*std::pow(z,2)) - \
					3.0*G[19]*y*z - 1.5*G[20]*x*y - 6*G[21]*y*z - 6*G[22]*x*y;

		// Calculating dBzdx
		dBidxj[2][0] = G[6] + 2*G[9]*y - 1.0*G[11]*x + 2*G[12]*z + 2*G[13]*x + \
					6*G[16]*x*y + 6*G[17]*y*z - 1.5*G[18]*x*y - 3.0*G[19]*x*z+\
					G[20]*(-2.25*std::pow(x,2) - 0.75*std::pow(y,2) + 3*std::pow(z,2)) + \
					6*G[21]*x*z + G[22]*(3*std::pow(x,2) - 3*std::pow(y,2));

		// Calculating dBzdy
		dBidxj[2][1] = G[4] + 2*G[9]*x + 2*G[10]*z - 1.0*G[11]*y - 2*G[13]*y + \
					G[16]*(3*std::pow(x,2) - 3*std::pow(y,2)) + 6*G[17]*x*z + \
					G[18]*(-0.75*std::pow(x,2) - 2.25*std::pow(y,2) + 3*std::pow(z,2)) - \
					3.0*G[19]*y*z - 1.5*G[20]*x*y - 6*G[21]*y*z - 6*G[22]*x*y;

		// Calculating dBzdz
		dBidxj[2][2] = G[5] + 2*G[10]*y + 2*G[11]*z + 2*G[12]*x + 6*G[17]*x*y + \
					6*G[18]*y*z + G[19]*(-1.5*std::pow(x,2) - 1.5*std::pow(y,2) + \
					3*std::pow(z,2)) + 6*G[20]*x*z + G[21]*(3*std::pow(x,2) -3*std::pow(y,2));
	}



	/********************************************************************************************************
	 * ROTATION IS NOT IMPLEMENTED CORRECTLY!
	 * IT JUST ROTATES THE RESULTING MAGNETIC FIELD VECTORS BUT DOES NOT DO A FULL COORDINATE TRANSFORMATION!
	 * CODE BELOW IS JUST LEFT FOR INFORMATIONAL PURPOSES! DO NOT USE!
	*********************************************************************************************************/



	/* 
	Information about Rotations with Quaternions

	from the double-specific constructor documentation of BOOST
	boost.org/doc/libs/1_70_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html

	explicit quaternion(double const & requested_a = 0.0, 
						double const & requested_b = 0.0, 
						double const & requested_c = 0.0, 
						double const & requested_d = 0.0);

	This constructs a quartention. From the useful wikipedia page on rotations
	and quartenions... wikipedia.org/wiki/Quaternions_and_spatial_rotation

	"In a programmatic implementation, this is achieved by constructing a 
	quaternion whose vector part is p and real part equals zero and then
	performing the quaternion multiplication. The vector part of the resulting 
	quaternion is the desired vector p′."

	here they refer to the original vector, which we want to rotate, as p. The 
	resulting, rotated, vector is called p'. Refer to the referenced wikipedia
	page for details on how to construct the desired quartenion q. On that 
	wikipedia page, an example rotation in 3D space is provided. 

	(!!!) due to the limitation of boost version within the UCN cluster, 
	we are not able to use the QVM library (earliest v1.62 of boost) which 
	contains more updated functionality specific to the rotations 
	implemented here. See http://boostorg.github.io/qvm/#quat_rotate
	and https://github.com/boostorg/qvm
	*/

	// The B vector is rotated, as well as the three dBxdxj, dBydxj dBzdxj 
	// directional gradient vectors, using the same quaternion conjugation.
	// This achieves a full rotation of the magnetic field and its spatial 
	// derivatives.

	// if the user provides values of 0 for every input to the axis of rotation
	// then no rotation is performed.
	if (axis_x != 0 || axis_y != 0 || axis_z != 0){

        // construct the quarternion, p, which represents the vector to be 
		// rotated
        // here the 0th component is equal to zero, and the remaining three 
        // components are those of the earlier computed magnetic field
        boost::math::quaternion<double> p(0, B[0], B[1], B[2]);

        // the components of the axis of rotation (member variables of this 
		// class) are used to construct a normalized vector.
        boost::numeric::ublas::vector<double> axis(3, 0);
        axis(0) = axis_x;
        axis(1) = axis_y;
        axis(2) = axis_z;

        // the rotational axis vector is normalized
        axis = (axis / boost::numeric::ublas::norm_2(axis));

        // calculate quarternion, q, whih represents the rotation
        boost::math::quaternion<double> q(std::cos(angle / 2), 
                                          std::sin(angle / 2) * axis(0), 
                                          std::sin(angle / 2) * axis(1), 
                                          std::sin(angle / 2) * axis(2));

        // get the conjugate of the quaternion, q'
        boost::math::quaternion<double> q_prime = boost::math::conj(q);

        // perform multiplication to rotate
        boost::math::quaternion<double> p_prime = q * p * q_prime;

        // extract the resulting vector components, post-rotation
        B[0] = p_prime.R_component_2();
        B[1] = p_prime.R_component_3();
        B[2] = p_prime.R_component_4();

		if (dBidxj != nullptr){
	        // We create three quaternions, one for the gradient of each of the 
	        // gradient vectors

			boost::math::quaternion<double> p_x(0, 
												dBidxj[0][0],
												dBidxj[0][1],
												dBidxj[0][2]);

			boost::math::quaternion<double> p_y(0, 
												dBidxj[1][0], 
												dBidxj[1][1], 
												dBidxj[1][2]);

			boost::math::quaternion<double> p_z(0, 
												dBidxj[2][0], 
												dBidxj[2][1], 
												dBidxj[2][2]);

			// we use the same quaternion, q, and conjugate q' for these rotations
			boost::math::quaternion<double> p_x_prime = q * p_x * q_prime;
			boost::math::quaternion<double> p_y_prime = q * p_y * q_prime;
			boost::math::quaternion<double> p_z_prime = q * p_z * q_prime;

			// extract the resulting vector components, post-rotation
			// assign the components to the dBidxj matrix
			dBidxj[0][0] = p_x_prime.R_component_2();
			dBidxj[0][1] = p_x_prime.R_component_3();
			dBidxj[0][2] = p_x_prime.R_component_4();

			dBidxj[1][0] = p_y_prime.R_component_2();
			dBidxj[1][1] = p_y_prime.R_component_3();
			dBidxj[1][2] = p_y_prime.R_component_4();

			dBidxj[2][0] = p_z_prime.R_component_2();
			dBidxj[2][1] = p_z_prime.R_component_3();
			dBidxj[2][2] = p_z_prime.R_component_4();
		

    	}

	}
}


using namespace boost::math::differentiation;

template<typename X, typename Y, typename Z>
constexpr promote<X, Y, Z> harmonicPolynomial(const unsigned int l, const int m, const X &x, const Y &y, const Z &z){
	typedef promote<X, Y, Z> Real;
	Real Clm = boost::math::factorial<Real>(l - 1)*pow(-2, abs(m))/boost::math::factorial<Real>(l + abs(m));
	Real phi = atan2(y, x);
	if (m >= 0){
		Clm = Clm * cos(m*phi);
	}
	else{
		Clm = Clm * sin(-m*phi);
	}
	Real r = sqrt(x*x + y*y + z*z);
	return Clm * pow(r, l) * boost::math::legendre_p(l, abs(m), z/r);
}


void HarmonicExpandedBField::BField_new(const double _x, const double _y, const double _z, const double t, double B[3], double dBidxj[3][3]) const{
	double x = _x + xoff;
	double y = _y + yoff;
	double z = _z + zoff;

	for (int i = 0; i < 3; ++i){
		B[i] = 0;
		for (int j = 0; j < 3 and dBidxj != nullptr; ++j){
			dBidxj[i][j] = 0;
		}
	}

	for (auto glm: Glm){
		int l = std::get<0>(glm);
		int m = std::get<1>(glm);
		double G = std::get<2>(glm);

		if (G == 0.) continue;

		auto const xyz = boost::math::differentiation::make_ftuple<double, 2, 2, 2>(x, y, z);
		auto const Sigma = harmonicPolynomial(l + 1, m, std::get<0>(xyz), std::get<1>(xyz), std::get<2>(xyz));
		B[0] = G*Sigma.derivative(1, 0, 0);
		B[1] = G*Sigma.derivative(0, 1, 0);
		B[2] = G*Sigma.derivative(0, 0, 1);
		if (dBidxj != nullptr){
			dBidxj[0][0] = G*Sigma.derivative(2, 0, 0);
			dBidxj[0][1] = G*Sigma.derivative(1, 1, 0);
			dBidxj[0][2] = G*Sigma.derivative(1, 0, 1);
			dBidxj[1][0] = G*Sigma.derivative(1, 1, 0);
			dBidxj[1][1] = G*Sigma.derivative(0, 2, 0);
			dBidxj[1][2] = G*Sigma.derivative(0, 1, 1);
			dBidxj[2][0] = G*Sigma.derivative(1, 0, 1);
			dBidxj[2][1] = G*Sigma.derivative(0, 1, 1);
			dBidxj[2][2] = G*Sigma.derivative(0, 0, 2);
		}
	}
}


