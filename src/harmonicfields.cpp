
/**
 * \file
 * Implementation of a magnetic field determined by 
 * coefficients, provided as inputs by the user, of an expansion in
 * terms of harmonic polynomials.
*/

#include "harmonicfields.h"
#include <iostream>
#include <cmath>
#include <boost/math/quaternion.hpp>
#include <boost/numeric/ublas/vector.hpp>

HarmonicExpandedBField::HarmonicExpandedBField(const double _xoff, const double _yoff, const double _zoff,
		const double _axis_x, const double _axis_y, const double _axis_z, const double _angle,
		const std::vector<std::tuple<int, int, double> > _Glm){
	
	if (_Glm.empty()){
		std::cerr << "Warning: you have defined a HarmonicExpansionBField with no coefficients. It will always evaluate to zero!";
	}

	if (_axis_x != 0. or _axis_y != 0. or _axis_z != 0. or _angle != 0.){
		throw std::runtime_error("I'm afraid the field rotations for the HarmonicExpandedBField are not implemented yet! Please set all rotation parameters to zero. Aborting...");
	}

	// the offset values
	xoff = _xoff;
	yoff = _yoff;
	zoff = _zoff;

	// parameters defining the axis-angle quaternion rotation
	axis_x = _axis_x;
	axis_y = _axis_y;
	axis_z = _axis_z;
	angle  = _angle;

	Glm = _Glm;

	for (auto glm: Glm){
		int l = std::get<0>(glm);
		int m = std::get<1>(glm);
		if (l < 0 or l > 5 or std::abs(m) > l + 1){
			throw std::runtime_error("You defined invalid HarmonicExpansionBField coefficients (l,m) = (" + std::to_string(l) + "," + std::to_string(m) + ")! Only values 0 <= l <= 5 and -l-1 <= m <= l+1 are allowed. Aborting...");
		}
	}
}


void HarmonicExpandedBField::BField(const double _x, const double _y, const double _z, const double t, double B[3], double dBidxj[3][3]) const{
	// Updating the x, y, z values with the given offset values
	double x = _x + xoff;
	double y = _y + yoff;
	double z = _z + zoff;

	for (int i = 0; i < 3; ++i){
		B[i] = 0;
		for (int j = 0; j < 3 and dBidxj != nullptr; ++j){
			dBidxj[i][j] = 0;
		}
	}

	for (auto glm: Glm){
		int l = std::get<0>(glm);
		int m = std::get<1>(glm);
		double G = std::get<2>(glm);

		if (G == 0.) continue;

		/* 
		 * The code below is autogenerated using Mathematica with the goal to allow the user to define an arbitrary set of Glm coeffcients up to 5th order.
		 * I tried to implement a general solution with associated Legendre polynomials but the expressions become extremely complicated, especially for the field gradients.
		 * This is hopefully faster.
		 * For more information about the harmonic polynomial decomposition see https://doi.org/10.1103/PhysRevA.99.042112
		*/
		if (l==0){
			if (m==-1){
				B[0] += 0;
				B[1] += G;
				B[2] += 0;
			}
			else if (m==0){
				B[0] += 0;
				B[1] += 0;
				B[2] += G;
			}
			else if (m==1){
				B[0] += G;
				B[1] += 0;
				B[2] += 0;
			}
		}
		else if (l==1){
			if (m==-2){
				B[0] += G*y;
				B[1] += G*x;
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 0;
					dBidxj[0][1] += G;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G;
					dBidxj[1][1] += 0;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-1){
				B[0] += 0;
				B[1] += G*z;
				B[2] += G*y;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 0;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += 0;
					dBidxj[1][2] += G;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += G;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==0){
				B[0] += -(G*x)/2.;
				B[1] += -(G*y)/2.;
				B[2] += G*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += -G/2.;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += -G/2.;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += G;
				}
			}
			else if (m==1){
				B[0] += G*z;
				B[1] += 0;
				B[2] += G*x;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 0;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += G;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += 0;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += G;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==2){
				B[0] += G*x;
				B[1] += -(G*y);
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += -G;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else if (l==2){
			if (m==-3){
				B[0] += 2*G*x*y;
				B[1] += G*(x - y)*(x + y);
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 2*G*y;
					dBidxj[0][1] += 2*G*x;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += 2*G*x;
					dBidxj[1][1] += -2*G*y;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-2){
				B[0] += 2*G*y*z;
				B[1] += 2*G*x*z;
				B[2] += 2*G*x*y;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 0;
					dBidxj[0][1] += 2*G*z;
					dBidxj[0][2] += 2*G*y;
					dBidxj[1][0] += 2*G*z;
					dBidxj[1][1] += 0;
					dBidxj[1][2] += 2*G*x;
					dBidxj[2][0] += 2*G*y;
					dBidxj[2][1] += 2*G*x;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-1){
				B[0] += -(G*x*y)/2.;
				B[1] += G*(-std::pow(x,2)/4. - (3*std::pow(y,2))/4. + std::pow(z,2));
				B[2] += 2*G*y*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += -(G*y)/2.;
					dBidxj[0][1] += -(G*x)/2.;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += -(G*x)/2.;
					dBidxj[1][1] += (-3*G*y)/2.;
					dBidxj[1][2] += 2*G*z;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 2*G*z;
					dBidxj[2][2] += 2*G*y;
				}
			}
			else if (m==0){
				B[0] += -(G*x*z);
				B[1] += -(G*y*z);
				B[2] += G*(-std::pow(x,2)/2. - std::pow(y,2)/2. + std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += -(G*z);
					dBidxj[0][1] += 0;
					dBidxj[0][2] += -(G*x);
					dBidxj[1][0] += 0;
					dBidxj[1][1] += -(G*z);
					dBidxj[1][2] += -(G*y);
					dBidxj[2][0] += -(G*x);
					dBidxj[2][1] += -(G*y);
					dBidxj[2][2] += 2*G*z;
				}
			}
			else if (m==1){
				B[0] += G*((-3*std::pow(x,2))/4. - std::pow(y,2)/4. + std::pow(z,2));
				B[1] += -(G*x*y)/2.;
				B[2] += 2*G*x*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (-3*G*x)/2.;
					dBidxj[0][1] += -(G*y)/2.;
					dBidxj[0][2] += 2*G*z;
					dBidxj[1][0] += -(G*y)/2.;
					dBidxj[1][1] += -(G*x)/2.;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 2*G*z;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 2*G*x;
				}
			}
			else if (m==2){
				B[0] += 2*G*x*z;
				B[1] += -2*G*y*z;
				B[2] += G*(x - y)*(x + y);
				if (dBidxj != nullptr){
					dBidxj[0][0] += 2*G*z;
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 2*G*x;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += -2*G*z;
					dBidxj[1][2] += -2*G*y;
					dBidxj[2][0] += 2*G*x;
					dBidxj[2][1] += -2*G*y;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==3){
				B[0] += G*(x - y)*(x + y);
				B[1] += -2*G*x*y;
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 2*G*x;
					dBidxj[0][1] += -2*G*y;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += -2*G*y;
					dBidxj[1][1] += -2*G*x;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else if (l==3){
			if (m==-4){
				B[0] += G*(3*std::pow(x,2)*y - std::pow(y,3));
				B[1] += G*(std::pow(x,3) - 3*x*std::pow(y,2));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += 6*G*x*y;
					dBidxj[0][1] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[1][1] += -6*G*x*y;
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-3){
				B[0] += 6*G*x*y*z;
				B[1] += 3*G*(x - y)*(x + y)*z;
				B[2] += G*(3*std::pow(x,2)*y - std::pow(y,3));
				if (dBidxj != nullptr){
					dBidxj[0][0] += 6*G*y*z;
					dBidxj[0][1] += 6*G*x*z;
					dBidxj[0][2] += 6*G*x*y;
					dBidxj[1][0] += G*(3*(x - y)*z + 3*(x + y)*z);
					dBidxj[1][1] += G*(3*(x - y)*z - 3*(x + y)*z);
					dBidxj[1][2] += 3*G*(x - y)*(x + y);
					dBidxj[2][0] += 6*G*x*y;
					dBidxj[2][1] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-2){
				B[0] += -(G*y*(3*std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.;
				B[1] += -(G*x*(std::pow(x,2) + 3*std::pow(y,2) - 6*std::pow(z,2)))/2.;
				B[2] += 6*G*x*y*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += -3*G*x*y;
					dBidxj[0][1] += G*(-std::pow(y,2) + (-3*std::pow(x,2) - std::pow(y,2) + 6*std::pow(z,2))/2.);
					dBidxj[0][2] += 6*G*y*z;
					dBidxj[1][0] += G*(-std::pow(x,2) + (-std::pow(x,2) - 3*std::pow(y,2) + 6*std::pow(z,2))/2.);
					dBidxj[1][1] += -3*G*x*y;
					dBidxj[1][2] += 6*G*x*z;
					dBidxj[2][0] += 6*G*y*z;
					dBidxj[2][1] += 6*G*x*z;
					dBidxj[2][2] += 6*G*x*y;
				}
			}
			else if (m==-1){
				B[0] += (-3*G*x*y*z)/2.;
				B[1] += G*((-3*(std::pow(x,2) + 3*std::pow(y,2))*z)/4. + std::pow(z,3));
				B[2] += (-3*G*y*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/4.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (-3*G*y*z)/2.;
					dBidxj[0][1] += (-3*G*x*z)/2.;
					dBidxj[0][2] += (-3*G*x*y)/2.;
					dBidxj[1][0] += (-3*G*x*z)/2.;
					dBidxj[1][1] += (-9*G*y*z)/2.;
					dBidxj[1][2] += G*((-3*(std::pow(x,2) + 3*std::pow(y,2)))/4. + 3*std::pow(z,2));
					dBidxj[2][0] += (-3*G*x*y)/2.;
					dBidxj[2][1] += G*((-3*std::pow(y,2))/2. - (3*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/4.);
					dBidxj[2][2] += 6*G*y*z;
				}
			}
			else if (m==0){
				B[0] += (3*G*x*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/8.;
				B[1] += (3*G*y*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/8.;
				B[2] += G*((-3*(std::pow(x,2) + std::pow(y,2))*z)/2. + std::pow(z,3));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((3*std::pow(x,2))/4. + (3*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/8.);
					dBidxj[0][1] += (3*G*x*y)/4.;
					dBidxj[0][2] += -3*G*x*z;
					dBidxj[1][0] += (3*G*x*y)/4.;
					dBidxj[1][1] += G*((3*std::pow(y,2))/4. + (3*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/8.);
					dBidxj[1][2] += -3*G*y*z;
					dBidxj[2][0] += -3*G*x*z;
					dBidxj[2][1] += -3*G*y*z;
					dBidxj[2][2] += G*((-3*(std::pow(x,2) + std::pow(y,2)))/2. + 3*std::pow(z,2));
				}
			}
			else if (m==1){
				B[0] += G*((-3*(3*std::pow(x,2) + std::pow(y,2))*z)/4. + std::pow(z,3));
				B[1] += (-3*G*x*y*z)/2.;
				B[2] += (-3*G*x*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/4.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (-9*G*x*z)/2.;
					dBidxj[0][1] += (-3*G*y*z)/2.;
					dBidxj[0][2] += G*((-3*(3*std::pow(x,2) + std::pow(y,2)))/4. + 3*std::pow(z,2));
					dBidxj[1][0] += (-3*G*y*z)/2.;
					dBidxj[1][1] += (-3*G*x*z)/2.;
					dBidxj[1][2] += (-3*G*x*y)/2.;
					dBidxj[2][0] += G*((-3*std::pow(x,2))/2. - (3*(std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)))/4.);
					dBidxj[2][1] += (-3*G*x*y)/2.;
					dBidxj[2][2] += 6*G*x*z;
				}
			}
			else if (m==2){
				B[0] += G*(-std::pow(x,3) + 3*x*std::pow(z,2));
				B[1] += G*(std::pow(y,3) - 3*y*std::pow(z,2));
				B[2] += 3*G*(x - y)*(x + y)*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-3*std::pow(x,2) + 3*std::pow(z,2));
					dBidxj[0][1] += 0;
					dBidxj[0][2] += 6*G*x*z;
					dBidxj[1][0] += 0;
					dBidxj[1][1] += G*(3*std::pow(y,2) - 3*std::pow(z,2));
					dBidxj[1][2] += -6*G*y*z;
					dBidxj[2][0] += G*(3*(x - y)*z + 3*(x + y)*z);
					dBidxj[2][1] += G*(3*(x - y)*z - 3*(x + y)*z);
					dBidxj[2][2] += 3*G*(x - y)*(x + y);
				}
			}
			else if (m==3){
				B[0] += 3*G*(x - y)*(x + y)*z;
				B[1] += -6*G*x*y*z;
				B[2] += G*(std::pow(x,3) - 3*x*std::pow(y,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(3*(x - y)*z + 3*(x + y)*z);
					dBidxj[0][1] += G*(3*(x - y)*z - 3*(x + y)*z);
					dBidxj[0][2] += 3*G*(x - y)*(x + y);
					dBidxj[1][0] += -6*G*y*z;
					dBidxj[1][1] += -6*G*x*z;
					dBidxj[1][2] += -6*G*x*y;
					dBidxj[2][0] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[2][1] += -6*G*x*y;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==4){
				B[0] += G*(std::pow(x,3) - 3*x*std::pow(y,2));
				B[1] += G*(-3*std::pow(x,2)*y + std::pow(y,3));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(3*std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[0][1] += -6*G*x*y;
					dBidxj[0][2] += 0;
					dBidxj[1][0] += -6*G*x*y;
					dBidxj[1][1] += G*(-3*std::pow(x,2) + 3*std::pow(y,2));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else if (l==4){
			if (m==-5){
				B[0] += 4*G*x*(x - y)*y*(x + y);
				B[1] += G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(4*x*(x - y)*y + 4*x*y*(x + y) + 4*(x - y)*y*(x + y));
					dBidxj[0][1] += G*(4*x*(x - y)*y + 4*x*(x - y)*(x + y) - 4*x*y*(x + y));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G*(4*std::pow(x,3) - 12*x*std::pow(y,2));
					dBidxj[1][1] += G*(-12*std::pow(x,2)*y + 4*std::pow(y,3));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-4){
				B[0] += -4*G*y*(-3*std::pow(x,2) + std::pow(y,2))*z;
				B[1] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
				B[2] += 4*G*x*(x - y)*y*(x + y);
				if (dBidxj != nullptr){
					dBidxj[0][0] += 24*G*x*y*z;
					dBidxj[0][1] += G*(-8*std::pow(y,2)*z - 4*(-3*std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[0][2] += -4*G*y*(-3*std::pow(x,2) + std::pow(y,2));
					dBidxj[1][0] += G*(8*std::pow(x,2)*z + 4*(std::pow(x,2) - 3*std::pow(y,2))*z);
					dBidxj[1][1] += -24*G*x*y*z;
					dBidxj[1][2] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[2][0] += G*(4*x*(x - y)*y + 4*x*y*(x + y) + 4*(x - y)*y*(x + y));
					dBidxj[2][1] += G*(4*x*(x - y)*y + 4*x*(x - y)*(x + y) - 4*x*y*(x + y));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-3){
				B[0] += -(G*x*y*(3*std::pow(x,2) + std::pow(y,2) - 12*std::pow(z,2)));
				B[1] += (G*(-3*std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) + 24*(x - y)*(x + y)*std::pow(z,2)))/4.;
				B[2] += -4*G*y*(-3*std::pow(x,2) + std::pow(y,2))*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-6*std::pow(x,2)*y - y*(3*std::pow(x,2) + std::pow(y,2) - 12*std::pow(z,2)));
					dBidxj[0][1] += G*(-2*x*std::pow(y,2) - x*(3*std::pow(x,2) + std::pow(y,2) - 12*std::pow(z,2)));
					dBidxj[0][2] += 24*G*x*y*z;
					dBidxj[1][0] += (G*(-12*std::pow(x,3) - 12*x*std::pow(y,2) + 24*(x - y)*std::pow(z,2) + 24*(x + y)*std::pow(z,2)))/4.;
					dBidxj[1][1] += (G*(-12*std::pow(x,2)*y + 20*std::pow(y,3) + 24*(x - y)*std::pow(z,2) - 24*(x + y)*std::pow(z,2)))/4.;
					dBidxj[1][2] += 12*G*(x - y)*(x + y)*z;
					dBidxj[2][0] += 24*G*x*y*z;
					dBidxj[2][1] += G*(-8*std::pow(y,2)*z - 4*(-3*std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[2][2] += -4*G*y*(-3*std::pow(x,2) + std::pow(y,2));
				}
			}
			else if (m==-2){
				B[0] += -2*G*y*z*(3*std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2));
				B[1] += -2*G*x*z*(std::pow(x,2) + 3*std::pow(y,2) - 2*std::pow(z,2));
				B[2] += -2*G*x*y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += -12*G*x*y*z;
					dBidxj[0][1] += G*(-4*std::pow(y,2)*z - 2*z*(3*std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[0][2] += G*(8*y*std::pow(z,2) - 2*y*(3*std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[1][0] += G*(-4*std::pow(x,2)*z - 2*z*(std::pow(x,2) + 3*std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[1][1] += -12*G*x*y*z;
					dBidxj[1][2] += G*(8*x*std::pow(z,2) - 2*x*(std::pow(x,2) + 3*std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][0] += G*(-4*std::pow(x,2)*y - 2*y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)));
					dBidxj[2][1] += G*(-4*x*std::pow(y,2) - 2*x*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)));
					dBidxj[2][2] += 24*G*x*y*z;
				}
			}
			else if (m==-1){
				B[0] += (G*x*y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.;
				B[1] += (G*(std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) - 12*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.;
				B[2] += G*(-3*y*(std::pow(x,2) + std::pow(y,2))*z + 4*y*std::pow(z,3));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(std::pow(x,2)*y + (y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[0][1] += G*(x*std::pow(y,2) + (x*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[0][2] += -6*G*x*y*z;
					dBidxj[1][0] += (G*(4*std::pow(x,3) + 12*x*std::pow(y,2) - 24*x*std::pow(z,2)))/8.;
					dBidxj[1][1] += (G*(12*std::pow(x,2)*y + 20*std::pow(y,3) - 72*y*std::pow(z,2)))/8.;
					dBidxj[1][2] += (G*(-24*(std::pow(x,2) + 3*std::pow(y,2))*z + 32*std::pow(z,3)))/8.;
					dBidxj[2][0] += -6*G*x*y*z;
					dBidxj[2][1] += G*(-6*std::pow(y,2)*z - 3*(std::pow(x,2) + std::pow(y,2))*z + 4*std::pow(z,3));
					dBidxj[2][2] += G*(-3*y*(std::pow(x,2) + std::pow(y,2)) + 12*y*std::pow(z,2));
				}
			}
			else if (m==0){
				B[0] += G*((3*x*(std::pow(x,2) + std::pow(y,2))*z)/2. - 2*x*std::pow(z,3));
				B[1] += G*((3*y*(std::pow(x,2) + std::pow(y,2))*z)/2. - 2*y*std::pow(z,3));
				B[2] += G*((3*std::pow(std::pow(x,2) + std::pow(y,2),2))/8. - 3*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + std::pow(z,4));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(3*std::pow(x,2)*z + (3*(std::pow(x,2) + std::pow(y,2))*z)/2. - 2*std::pow(z,3));
					dBidxj[0][1] += 3*G*x*y*z;
					dBidxj[0][2] += G*((3*x*(std::pow(x,2) + std::pow(y,2)))/2. - 6*x*std::pow(z,2));
					dBidxj[1][0] += 3*G*x*y*z;
					dBidxj[1][1] += G*(3*std::pow(y,2)*z + (3*(std::pow(x,2) + std::pow(y,2))*z)/2. - 2*std::pow(z,3));
					dBidxj[1][2] += G*((3*y*(std::pow(x,2) + std::pow(y,2)))/2. - 6*y*std::pow(z,2));
					dBidxj[2][0] += G*((3*x*(std::pow(x,2) + std::pow(y,2)))/2. - 6*x*std::pow(z,2));
					dBidxj[2][1] += G*((3*y*(std::pow(x,2) + std::pow(y,2)))/2. - 6*y*std::pow(z,2));
					dBidxj[2][2] += G*(-6*(std::pow(x,2) + std::pow(y,2))*z + 4*std::pow(z,3));
				}
			}
			else if (m==1){
				B[0] += (G*(5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4) - 12*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.;
				B[1] += (G*x*y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.;
				B[2] += G*(-3*x*(std::pow(x,2) + std::pow(y,2))*z + 4*x*std::pow(z,3));
				if (dBidxj != nullptr){
					dBidxj[0][0] += (G*(20*std::pow(x,3) + 12*x*std::pow(y,2) - 72*x*std::pow(z,2)))/8.;
					dBidxj[0][1] += (G*(12*std::pow(x,2)*y + 4*std::pow(y,3) - 24*y*std::pow(z,2)))/8.;
					dBidxj[0][2] += (G*(-24*(3*std::pow(x,2) + std::pow(y,2))*z + 32*std::pow(z,3)))/8.;
					dBidxj[1][0] += G*(std::pow(x,2)*y + (y*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[1][1] += G*(x*std::pow(y,2) + (x*(std::pow(x,2) + std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[1][2] += -6*G*x*y*z;
					dBidxj[2][0] += G*(-6*std::pow(x,2)*z - 3*(std::pow(x,2) + std::pow(y,2))*z + 4*std::pow(z,3));
					dBidxj[2][1] += -6*G*x*y*z;
					dBidxj[2][2] += G*(-3*x*(std::pow(x,2) + std::pow(y,2)) + 12*x*std::pow(z,2));
				}
			}
			else if (m==2){
				B[0] += -4*G*x*(x - z)*z*(x + z);
				B[1] += 4*G*y*(y - z)*z*(y + z);
				B[2] += G*(-std::pow(x,4) + std::pow(y,4) + 6*(x - y)*(x + y)*std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-4*x*(x - z)*z - 4*x*z*(x + z) - 4*(x - z)*z*(x + z));
					dBidxj[0][1] += 0;
					dBidxj[0][2] += G*(-4*x*(x - z)*z - 4*x*(x - z)*(x + z) + 4*x*z*(x + z));
					dBidxj[1][0] += 0;
					dBidxj[1][1] += G*(4*y*(y - z)*z + 4*y*z*(y + z) + 4*(y - z)*z*(y + z));
					dBidxj[1][2] += G*(4*y*(y - z)*z + 4*y*(y - z)*(y + z) - 4*y*z*(y + z));
					dBidxj[2][0] += G*(-4*std::pow(x,3) + 6*(x - y)*std::pow(z,2) + 6*(x + y)*std::pow(z,2));
					dBidxj[2][1] += G*(4*std::pow(y,3) + 6*(x - y)*std::pow(z,2) - 6*(x + y)*std::pow(z,2));
					dBidxj[2][2] += 12*G*(x - y)*(x + y)*z;
				}
			}
			else if (m==3){
				B[0] += (G*(-5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 3*std::pow(y,4) + 24*(x - y)*(x + y)*std::pow(z,2)))/4.;
				B[1] += G*x*y*(std::pow(x,2) + 3*(std::pow(y,2) - 4*std::pow(z,2)));
				B[2] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (G*(-20*std::pow(x,3) + 12*x*std::pow(y,2) + 24*(x - y)*std::pow(z,2) + 24*(x + y)*std::pow(z,2)))/4.;
					dBidxj[0][1] += (G*(12*std::pow(x,2)*y + 12*std::pow(y,3) + 24*(x - y)*std::pow(z,2) - 24*(x + y)*std::pow(z,2)))/4.;
					dBidxj[0][2] += 12*G*(x - y)*(x + y)*z;
					dBidxj[1][0] += G*(2*std::pow(x,2)*y + y*(std::pow(x,2) + 3*(std::pow(y,2) - 4*std::pow(z,2))));
					dBidxj[1][1] += G*(6*x*std::pow(y,2) + x*(std::pow(x,2) + 3*(std::pow(y,2) - 4*std::pow(z,2))));
					dBidxj[1][2] += -24*G*x*y*z;
					dBidxj[2][0] += G*(8*std::pow(x,2)*z + 4*(std::pow(x,2) - 3*std::pow(y,2))*z);
					dBidxj[2][1] += -24*G*x*y*z;
					dBidxj[2][2] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2));
				}
			}
			else if (m==4){
				B[0] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
				B[1] += 4*G*y*(-3*std::pow(x,2) + std::pow(y,2))*z;
				B[2] += G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(8*std::pow(x,2)*z + 4*(std::pow(x,2) - 3*std::pow(y,2))*z);
					dBidxj[0][1] += -24*G*x*y*z;
					dBidxj[0][2] += 4*G*x*(std::pow(x,2) - 3*std::pow(y,2));
					dBidxj[1][0] += -24*G*x*y*z;
					dBidxj[1][1] += G*(8*std::pow(y,2)*z + 4*(-3*std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[1][2] += 4*G*y*(-3*std::pow(x,2) + std::pow(y,2));
					dBidxj[2][0] += G*(4*std::pow(x,3) - 12*x*std::pow(y,2));
					dBidxj[2][1] += G*(-12*std::pow(x,2)*y + 4*std::pow(y,3));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==5){
				B[0] += G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
				B[1] += 4*G*x*y*(-std::pow(x,2) + std::pow(y,2));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(4*std::pow(x,3) - 12*x*std::pow(y,2));
					dBidxj[0][1] += G*(-12*std::pow(x,2)*y + 4*std::pow(y,3));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G*(-8*std::pow(x,2)*y + 4*y*(-std::pow(x,2) + std::pow(y,2)));
					dBidxj[1][1] += G*(8*x*std::pow(y,2) + 4*x*(-std::pow(x,2) + std::pow(y,2)));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else if (l==5){
			if (m==-6){
				B[0] += G*(5*std::pow(x,4)*y - 10*std::pow(x,2)*std::pow(y,3) + std::pow(y,5));
				B[1] += G*(std::pow(x,5) - 10*std::pow(x,3)*std::pow(y,2) + 5*x*std::pow(y,4));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(20*std::pow(x,3)*y - 20*x*std::pow(y,3));
					dBidxj[0][1] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[1][1] += G*(-20*std::pow(x,3)*y + 20*x*std::pow(y,3));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-5){
				B[0] += 20*G*x*(x - y)*y*(x + y)*z;
				B[1] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4))*z;
				B[2] += G*(5*std::pow(x,4)*y - 10*std::pow(x,2)*std::pow(y,3) + std::pow(y,5));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(20*x*(x - y)*y*z + 20*x*y*(x + y)*z + 20*(x - y)*y*(x + y)*z);
					dBidxj[0][1] += G*(20*x*(x - y)*y*z + 20*x*(x - y)*(x + y)*z - 20*x*y*(x + y)*z);
					dBidxj[0][2] += 20*G*x*(x - y)*y*(x + y);
					dBidxj[1][0] += 5*G*(4*std::pow(x,3) - 12*x*std::pow(y,2))*z;
					dBidxj[1][1] += 5*G*(-12*std::pow(x,2)*y + 4*std::pow(y,3))*z;
					dBidxj[1][2] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
					dBidxj[2][0] += G*(20*std::pow(x,3)*y - 20*x*std::pow(y,3));
					dBidxj[2][1] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==-4){
				B[0] += G*(-5*std::pow(x,4)*y + std::pow(y,5) + 30*std::pow(x,2)*y*std::pow(z,2) - 10*std::pow(y,3)*std::pow(z,2));
				B[1] += G*x*(-std::pow(x,4) + 5*std::pow(y,4) + 10*(std::pow(x,2) - 3*std::pow(y,2))*std::pow(z,2));
				B[2] += 20*G*x*(x - y)*y*(x + y)*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-20*std::pow(x,3)*y + 60*x*y*std::pow(z,2));
					dBidxj[0][1] += G*(-5*std::pow(x,4) + 5*std::pow(y,4) + 30*std::pow(x,2)*std::pow(z,2) - 30*std::pow(y,2)*std::pow(z,2));
					dBidxj[0][2] += G*(60*std::pow(x,2)*y*z - 20*std::pow(y,3)*z);
					dBidxj[1][0] += G*(-std::pow(x,4) + 5*std::pow(y,4) + 10*(std::pow(x,2) - 3*std::pow(y,2))*std::pow(z,2) + x*(-4*std::pow(x,3) + 20*x*std::pow(z,2)));
					dBidxj[1][1] += G*x*(20*std::pow(y,3) - 60*y*std::pow(z,2));
					dBidxj[1][2] += 20*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
					dBidxj[2][0] += G*(20*x*(x - y)*y*z + 20*x*y*(x + y)*z + 20*(x - y)*y*(x + y)*z);
					dBidxj[2][1] += G*(20*x*(x - y)*y*z + 20*x*(x - y)*(x + y)*z - 20*x*y*(x + y)*z);
					dBidxj[2][2] += 20*G*x*(x - y)*y*(x + y);
				}
			}
			else if (m==-3){
				B[0] += -5*G*x*y*z*(3*std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2));
				B[1] += (5*G*z*(-3*std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) + 8*(x - y)*(x + y)*std::pow(z,2)))/4.;
				B[2] += (5*G*y*(-3*std::pow(x,2) + std::pow(y,2))*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/4.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(-30*std::pow(x,2)*y*z - 5*y*z*(3*std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[0][1] += G*(-10*x*std::pow(y,2)*z - 5*x*z*(3*std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[0][2] += G*(40*x*y*std::pow(z,2) - 5*x*y*(3*std::pow(x,2) + std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[1][0] += (5*G*z*(-12*std::pow(x,3) - 12*x*std::pow(y,2) + 8*(x - y)*std::pow(z,2) + 8*(x + y)*std::pow(z,2)))/4.;
					dBidxj[1][1] += (5*G*z*(-12*std::pow(x,2)*y + 20*std::pow(y,3) + 8*(x - y)*std::pow(z,2) - 8*(x + y)*std::pow(z,2)))/4.;
					dBidxj[1][2] += G*(20*(x - y)*(x + y)*std::pow(z,2) + (5*(-3*std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) + 8*(x - y)*(x + y)*std::pow(z,2)))/4.);
					dBidxj[2][0] += G*((5*x*y*(-3*std::pow(x,2) + std::pow(y,2)))/2. - (15*x*y*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/2.);
					dBidxj[2][1] += G*((5*std::pow(y,2)*(-3*std::pow(x,2) + std::pow(y,2)))/2. + (5*std::pow(y,2)*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/2. + (5*(-3*std::pow(x,2) + std::pow(y,2))*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/4.);
					dBidxj[2][2] += -20*G*y*(-3*std::pow(x,2) + std::pow(y,2))*z;
				}
			}
			else if (m==-2){
				B[0] += (5*G*y*(5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4) - 16*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 16*std::pow(z,4)))/16.;
				B[1] += (5*G*x*(std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) - 16*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,2) + 16*std::pow(z,4)))/16.;
				B[2] += -10*G*x*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += (5*G*y*(20*std::pow(x,3) + 12*x*std::pow(y,2) - 96*x*std::pow(z,2)))/16.;
					dBidxj[0][1] += G*((5*y*(12*std::pow(x,2)*y + 4*std::pow(y,3) - 32*y*std::pow(z,2)))/16. + (5*(5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4) - 16*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 16*std::pow(z,4)))/16.);
					dBidxj[0][2] += (5*G*y*(-32*(3*std::pow(x,2) + std::pow(y,2))*z + 64*std::pow(z,3)))/16.;
					dBidxj[1][0] += G*((5*x*(4*std::pow(x,3) + 12*x*std::pow(y,2) - 32*x*std::pow(z,2)))/16. + (5*(std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4) - 16*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,2) + 16*std::pow(z,4)))/16.);
					dBidxj[1][1] += (5*G*x*(12*std::pow(x,2)*y + 20*std::pow(y,3) - 96*y*std::pow(z,2)))/16.;
					dBidxj[1][2] += (5*G*x*(-32*(std::pow(x,2) + 3*std::pow(y,2))*z + 64*std::pow(z,3)))/16.;
					dBidxj[2][0] += G*(-20*std::pow(x,2)*y*z - 10*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][1] += G*(-20*x*std::pow(y,2)*z - 10*x*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][2] += G*(40*x*y*std::pow(z,2) - 10*x*y*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
				}
			}
			else if (m==-1){
				B[0] += (5*G*x*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.;
				B[1] += G*((5*(std::pow(x,2) + std::pow(y,2))*(std::pow(x,2) + 5*std::pow(y,2))*z)/8. - (5*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,3))/2. + std::pow(z,5));
				B[2] += (5*G*y*(std::pow(std::pow(x,2) + std::pow(y,2),2) - 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(5*std::pow(x,2)*y*z + (5*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[0][1] += G*(5*x*std::pow(y,2)*z + (5*x*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[0][2] += G*(-10*x*y*std::pow(z,2) + (5*x*y*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[1][0] += G*((5*x*(std::pow(x,2) + std::pow(y,2))*z)/4. + (5*x*(std::pow(x,2) + 5*std::pow(y,2))*z)/4. - 5*x*std::pow(z,3));
					dBidxj[1][1] += G*((25*y*(std::pow(x,2) + std::pow(y,2))*z)/4. + (5*y*(std::pow(x,2) + 5*std::pow(y,2))*z)/4. - 15*y*std::pow(z,3));
					dBidxj[1][2] += G*((5*(std::pow(x,2) + std::pow(y,2))*(std::pow(x,2) + 5*std::pow(y,2)))/8. - (15*(std::pow(x,2) + 3*std::pow(y,2))*std::pow(z,2))/2. + 5*std::pow(z,4));
					dBidxj[2][0] += (5*G*y*(4*x*(std::pow(x,2) + std::pow(y,2)) - 24*x*std::pow(z,2)))/8.;
					dBidxj[2][1] += G*((5*y*(4*y*(std::pow(x,2) + std::pow(y,2)) - 24*y*std::pow(z,2)))/8. + (5*(std::pow(std::pow(x,2) + std::pow(y,2),2) - 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.);
					dBidxj[2][2] += (5*G*y*(-24*(std::pow(x,2) + std::pow(y,2))*z + 32*std::pow(z,3)))/8.;
				}
			}
			else if (m==0){
				B[0] += (5*G*x*(-std::pow(std::pow(x,2) + std::pow(y,2),2) + 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) - 8*std::pow(z,4)))/16.;
				B[1] += (5*G*y*(-std::pow(std::pow(x,2) + std::pow(y,2),2) + 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) - 8*std::pow(z,4)))/16.;
				B[2] += G*((15*std::pow(std::pow(x,2) + std::pow(y,2),2)*z)/8. - 5*(std::pow(x,2) + std::pow(y,2))*std::pow(z,3) + std::pow(z,5));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((5*x*(-4*x*(std::pow(x,2) + std::pow(y,2)) + 24*x*std::pow(z,2)))/16. + (5*(-std::pow(std::pow(x,2) + std::pow(y,2),2) + 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) - 8*std::pow(z,4)))/16.);
					dBidxj[0][1] += (5*G*x*(-4*y*(std::pow(x,2) + std::pow(y,2)) + 24*y*std::pow(z,2)))/16.;
					dBidxj[0][2] += (5*G*x*(24*(std::pow(x,2) + std::pow(y,2))*z - 32*std::pow(z,3)))/16.;
					dBidxj[1][0] += (5*G*y*(-4*x*(std::pow(x,2) + std::pow(y,2)) + 24*x*std::pow(z,2)))/16.;
					dBidxj[1][1] += G*((5*y*(-4*y*(std::pow(x,2) + std::pow(y,2)) + 24*y*std::pow(z,2)))/16. + (5*(-std::pow(std::pow(x,2) + std::pow(y,2),2) + 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) - 8*std::pow(z,4)))/16.);
					dBidxj[1][2] += (5*G*y*(24*(std::pow(x,2) + std::pow(y,2))*z - 32*std::pow(z,3)))/16.;
					dBidxj[2][0] += G*((15*x*(std::pow(x,2) + std::pow(y,2))*z)/2. - 10*x*std::pow(z,3));
					dBidxj[2][1] += G*((15*y*(std::pow(x,2) + std::pow(y,2))*z)/2. - 10*y*std::pow(z,3));
					dBidxj[2][2] += G*((15*std::pow(std::pow(x,2) + std::pow(y,2),2))/8. - 15*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 5*std::pow(z,4));
				}
			}
			else if (m==1){
				B[0] += G*((5*(std::pow(x,2) + std::pow(y,2))*(5*std::pow(x,2) + std::pow(y,2))*z)/8. - (5*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,3))/2. + std::pow(z,5));
				B[1] += (5*G*x*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.;
				B[2] += (5*G*x*(std::pow(std::pow(x,2) + std::pow(y,2),2) - 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((25*x*(std::pow(x,2) + std::pow(y,2))*z)/4. + (5*x*(5*std::pow(x,2) + std::pow(y,2))*z)/4. - 15*x*std::pow(z,3));
					dBidxj[0][1] += G*((5*y*(std::pow(x,2) + std::pow(y,2))*z)/4. + (5*y*(5*std::pow(x,2) + std::pow(y,2))*z)/4. - 5*y*std::pow(z,3));
					dBidxj[0][2] += G*((5*(std::pow(x,2) + std::pow(y,2))*(5*std::pow(x,2) + std::pow(y,2)))/8. - (15*(3*std::pow(x,2) + std::pow(y,2))*std::pow(z,2))/2. + 5*std::pow(z,4));
					dBidxj[1][0] += G*(5*std::pow(x,2)*y*z + (5*y*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[1][1] += G*(5*x*std::pow(y,2)*z + (5*x*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[1][2] += G*(-10*x*y*std::pow(z,2) + (5*x*y*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)))/2.);
					dBidxj[2][0] += G*((5*x*(4*x*(std::pow(x,2) + std::pow(y,2)) - 24*x*std::pow(z,2)))/8. + (5*(std::pow(std::pow(x,2) + std::pow(y,2),2) - 12*(std::pow(x,2) + std::pow(y,2))*std::pow(z,2) + 8*std::pow(z,4)))/8.);
					dBidxj[2][1] += (5*G*x*(4*y*(std::pow(x,2) + std::pow(y,2)) - 24*y*std::pow(z,2)))/8.;
					dBidxj[2][2] += (5*G*x*(-24*(std::pow(x,2) + std::pow(y,2))*z + 32*std::pow(z,3)))/8.;
				}
			}
			else if (m==2){
				B[0] += (5*G*x*(3*std::pow(x,4) - std::pow(y,4) + 16*std::pow(z,4) + 2*std::pow(x,2)*(std::pow(y,2) - 16*std::pow(z,2))))/16.;
				B[1] += (5*G*y*(std::pow(x,4) - 2*std::pow(x,2)*std::pow(y,2) - 3*std::pow(y,4) + 32*std::pow(y,2)*std::pow(z,2) - 16*std::pow(z,4)))/16.;
				B[2] += -5*G*(x - y)*(x + y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2));
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((5*x*(12*std::pow(x,3) + 4*x*(std::pow(y,2) - 16*std::pow(z,2))))/16. + (5*(3*std::pow(x,4) - std::pow(y,4) + 16*std::pow(z,4) + 2*std::pow(x,2)*(std::pow(y,2) - 16*std::pow(z,2))))/16.);
					dBidxj[0][1] += (5*G*x*(4*std::pow(x,2)*y - 4*std::pow(y,3)))/16.;
					dBidxj[0][2] += (5*G*x*(-64*std::pow(x,2)*z + 64*std::pow(z,3)))/16.;
					dBidxj[1][0] += (5*G*y*(4*std::pow(x,3) - 4*x*std::pow(y,2)))/16.;
					dBidxj[1][1] += G*((5*y*(-4*std::pow(x,2)*y - 12*std::pow(y,3) + 64*y*std::pow(z,2)))/16. + (5*(std::pow(x,4) - 2*std::pow(x,2)*std::pow(y,2) - 3*std::pow(y,4) + 32*std::pow(y,2)*std::pow(z,2) - 16*std::pow(z,4)))/16.);
					dBidxj[1][2] += (5*G*y*(64*std::pow(y,2)*z - 64*std::pow(z,3)))/16.;
					dBidxj[2][0] += G*(-10*x*(x - y)*(x + y)*z - 5*(x - y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)) - 5*(x + y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][1] += G*(-10*(x - y)*y*(x + y)*z - 5*(x - y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)) + 5*(x + y)*z*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
					dBidxj[2][2] += G*(20*(x - y)*(x + y)*std::pow(z,2) - 5*(x - y)*(x + y)*(std::pow(x,2) + std::pow(y,2) - 2*std::pow(z,2)));
				}
			}
			else if (m==3){
				B[0] += (5*G*z*(-5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 3*std::pow(y,4) + 8*(x - y)*(x + y)*std::pow(z,2)))/4.;
				B[1] += 5*G*x*y*z*(std::pow(x,2) + 3*std::pow(y,2) - 4*std::pow(z,2));
				B[2] += (-5*G*x*(std::pow(x,2) - 3*std::pow(y,2))*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/4.;
				if (dBidxj != nullptr){
					dBidxj[0][0] += (5*G*z*(-20*std::pow(x,3) + 12*x*std::pow(y,2) + 8*(x - y)*std::pow(z,2) + 8*(x + y)*std::pow(z,2)))/4.;
					dBidxj[0][1] += (5*G*z*(12*std::pow(x,2)*y + 12*std::pow(y,3) + 8*(x - y)*std::pow(z,2) - 8*(x + y)*std::pow(z,2)))/4.;
					dBidxj[0][2] += G*(20*(x - y)*(x + y)*std::pow(z,2) + (5*(-5*std::pow(x,4) + 6*std::pow(x,2)*std::pow(y,2) + 3*std::pow(y,4) + 8*(x - y)*(x + y)*std::pow(z,2)))/4.);
					dBidxj[1][0] += G*(10*std::pow(x,2)*y*z + 5*y*z*(std::pow(x,2) + 3*std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[1][1] += G*(30*x*std::pow(y,2)*z + 5*x*z*(std::pow(x,2) + 3*std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[1][2] += G*(-40*x*y*std::pow(z,2) + 5*x*y*(std::pow(x,2) + 3*std::pow(y,2) - 4*std::pow(z,2)));
					dBidxj[2][0] += G*((-5*std::pow(x,2)*(std::pow(x,2) - 3*std::pow(y,2)))/2. - (5*std::pow(x,2)*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/2. - (5*(std::pow(x,2) - 3*std::pow(y,2))*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/4.);
					dBidxj[2][1] += G*((-5*x*y*(std::pow(x,2) - 3*std::pow(y,2)))/2. + (15*x*y*(std::pow(x,2) + std::pow(y,2) - 8*std::pow(z,2)))/2.);
					dBidxj[2][2] += 20*G*x*(std::pow(x,2) - 3*std::pow(y,2))*z;
				}
			}
			else if (m==4){
				B[0] += G*((-3*std::pow(x,5))/2. + 5*std::pow(x,3)*(std::pow(y,2) + 2*std::pow(z,2)) + (5*x*(std::pow(y,4) - 12*std::pow(y,2)*std::pow(z,2)))/2.);
				B[1] += (G*y*(5*std::pow(x,4) - 3*std::pow(y,4) + 20*std::pow(y,2)*std::pow(z,2) + 10*std::pow(x,2)*(std::pow(y,2) - 6*std::pow(z,2))))/2.;
				B[2] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4))*z;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*((-15*std::pow(x,4))/2. + 15*std::pow(x,2)*(std::pow(y,2) + 2*std::pow(z,2)) + (5*(std::pow(y,4) - 12*std::pow(y,2)*std::pow(z,2)))/2.);
					dBidxj[0][1] += G*(10*std::pow(x,3)*y + (5*x*(4*std::pow(y,3) - 24*y*std::pow(z,2)))/2.);
					dBidxj[0][2] += G*(20*std::pow(x,3)*z - 60*x*std::pow(y,2)*z);
					dBidxj[1][0] += (G*y*(20*std::pow(x,3) + 20*x*(std::pow(y,2) - 6*std::pow(z,2))))/2.;
					dBidxj[1][1] += G*((y*(20*std::pow(x,2)*y - 12*std::pow(y,3) + 40*y*std::pow(z,2)))/2. + (5*std::pow(x,4) - 3*std::pow(y,4) + 20*std::pow(y,2)*std::pow(z,2) + 10*std::pow(x,2)*(std::pow(y,2) - 6*std::pow(z,2)))/2.);
					dBidxj[1][2] += (G*y*(-120*std::pow(x,2)*z + 40*std::pow(y,2)*z))/2.;
					dBidxj[2][0] += 5*G*(4*std::pow(x,3) - 12*x*std::pow(y,2))*z;
					dBidxj[2][1] += 5*G*(-12*std::pow(x,2)*y + 4*std::pow(y,3))*z;
					dBidxj[2][2] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
				}
			}
			else if (m==5){
				B[0] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4))*z;
				B[1] += 20*G*x*y*(-std::pow(x,2) + std::pow(y,2))*z;
				B[2] += G*(std::pow(x,5) - 10*std::pow(x,3)*std::pow(y,2) + 5*x*std::pow(y,4));
				if (dBidxj != nullptr){
					dBidxj[0][0] += 5*G*(4*std::pow(x,3) - 12*x*std::pow(y,2))*z;
					dBidxj[0][1] += 5*G*(-12*std::pow(x,2)*y + 4*std::pow(y,3))*z;
					dBidxj[0][2] += 5*G*(std::pow(x,4) - 6*std::pow(x,2)*std::pow(y,2) + std::pow(y,4));
					dBidxj[1][0] += G*(-40*std::pow(x,2)*y*z + 20*y*(-std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[1][1] += G*(40*x*std::pow(y,2)*z + 20*x*(-std::pow(x,2) + std::pow(y,2))*z);
					dBidxj[1][2] += 20*G*x*y*(-std::pow(x,2) + std::pow(y,2));
					dBidxj[2][0] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[2][1] += G*(-20*std::pow(x,3)*y + 20*x*std::pow(y,3));
					dBidxj[2][2] += 0;
				}
			}
			else if (m==6){
				B[0] += G*(std::pow(x,5) - 10*std::pow(x,3)*std::pow(y,2) + 5*x*std::pow(y,4));
				B[1] += -(G*y*(5*std::pow(x,4) - 10*std::pow(x,2)*std::pow(y,2) + std::pow(y,4)));
				B[2] += 0;
				if (dBidxj != nullptr){
					dBidxj[0][0] += G*(5*std::pow(x,4) - 30*std::pow(x,2)*std::pow(y,2) + 5*std::pow(y,4));
					dBidxj[0][1] += G*(-20*std::pow(x,3)*y + 20*x*std::pow(y,3));
					dBidxj[0][2] += 0;
					dBidxj[1][0] += -(G*y*(20*std::pow(x,3) - 20*x*std::pow(y,2)));
					dBidxj[1][1] += G*(-5*std::pow(x,4) + 10*std::pow(x,2)*std::pow(y,2) - std::pow(y,4) - y*(-20*std::pow(x,2)*y + 4*std::pow(y,3)));
					dBidxj[1][2] += 0;
					dBidxj[2][0] += 0;
					dBidxj[2][1] += 0;
					dBidxj[2][2] += 0;
				}
			}
		}
		else{
			throw std::runtime_error("Tried to evaluate HarmonicExpansionBField with invalid parameters! Aborting...");
		}
	}

}

void HarmonicExpandedBField::BField_old(const double _x, const double _y, const double _z, const double t, double B[3], double dBidxj[3][3]) const{

	// Updating the x, y, z values with the given offset values
	double x = _x + xoff;
	double y = _y + yoff;
	double z = _z + zoff;

	/* 
	Information about Calculating the Harmonic Polynomial Expansion

	The calculations below are hard-coded using the cartesian form of the 
	harmonic polynomial expansion. Alternatively, this can be carried out 
	in an iterative fashion using the BOOST library for "Legendre and 
	associated polynomials":
	
	boost.org/doc/libs/1_65_0/libs/math/doc/html/math_toolkit/sf_poly/legendre.html 

	This was not chosen for the implementation here because it was believed
	that this hard-coded representation displayed the physical form of the 
	functions more explicitly. Perhaps more importantly, this form is much
	easier to debug. 

	If in future, simulations wish to explore harmonic expansions above third 
	order, returning to an implementation using BOOST's legendre library may
	be preferrable. 
	*/

	std::vector<double> G(24, 0.);
	for (auto glm: Glm){
		int l = std::get<0>(glm);
		int m = std::get<1>(glm);
		double g = std::get<2>(glm);
		G[l*(l + 2) + (m + l + 1)] = g;
	}

	// Calculating B_x
	B[0] = 	  G[2] 	\
			+ G[3]  * (y) \
			+ G[5]  * (-x / 2) \
			+ G[6]  * (z) \
			+ G[7]  * (x) \
			+ G[8]  * (2 * x * y) \
			+ G[9]  * (2 * y * z) \
			+ G[10] * (-x * y / 2) \
			+ G[11] * (-x * z) \
			+ G[12] * (-(3 * std::pow(x,2) + std::pow(y,2) - 4 * std::pow(z,2)) / 4) \
			+ G[13] * (2 * x * z) \
			+ G[14] * ((std::pow(x,2) - std::pow(y,2))) \
			+ G[15] * ((3 * std::pow(x,2) * y - std::pow(y,3))) \
			+ G[16] * (6 * x * y * z) \
			+ G[17] * (-(3 * std::pow(x,2) * y + std::pow(y,3) - 6 * y * std::pow(z,2)) / 2) \
			+ G[18] * (-(3. / 2) * (x * y * z)) \
			+ G[19] * ((3. / 8) * (std::pow(x,3) + x * std::pow(y,2) - 4 * x * std::pow(z,2))) \
			+ G[20] * ((-1. / 4) * (9 * std::pow(x,2) * z + 3 * std::pow(y,2) * z - 4 * std::pow(z,3))) \
			+ G[21] * (-std::pow(x,3) + 3 * x * std::pow(z,2)) \
			+ G[22] * (3 * (std::pow(x,2) * z - std::pow(y,2) * z)) \
			+ G[23] * (std::pow(x,3) - 3 * x * std::pow(y,2));
	
	// Calculating B_y
	B[1] =	  G[0] 	\
			+ G[3]  * (x) \
			+ G[4]  * (z) \
			+ G[5]  * (-y / 2) \
			+ G[7]  * (-y) \
			+ G[8]  * (std::pow(x,2) - std::pow(y,2)) \
			+ G[9]  * (2 * x * z) \
			+ G[10] * ((std::pow(x,2) + 3 * std::pow(y,2) - 4 * std::pow(z,2)) / -4) \
			+ G[11] * (-y * z) \
			+ G[12] * (-x * y / 2) \
			+ G[13] * (-2 * y * z) \
			+ G[14] * (-2 * x * y) \
			+ G[15] * (std::pow(x,3) - 3 * x * std::pow(y,2)) \
			+ G[16] * (3 * (std::pow(x,2) * z - std::pow(y,2) * z)) \
			+ G[17] * (-(std::pow(x,3) + 3 * x * std::pow(y,2) - 6 * x * std::pow(z,2)) / 2) \
			+ G[18] * ( (-1. / 4) * (3 * std::pow(x,2) * z + 9 * std::pow(y,2) * z - 4 * std::pow(z,3))) \
			+ G[19] * ((3. / 8) * (std::pow(x,2) * y + std::pow(y,3) - 4 * y * std::pow(z,2))) \
			+ G[20] * ((-3. / 2) * x * y * z) \
			+ G[21] * (-3 * y * std::pow(z,2) + std::pow(y,3)) \
			+ G[22] * (-6 * x * y * z) \
			+ G[23] * (-3 * std::pow(x,2) * y + std::pow(y,3));

	// Calculating B_z
	B[2] =	  G[1] 	\
			+ G[4]  * (y) \
			+ G[5]  * (z) \
			+ G[6]  * (x) \
			+ G[9]  * (2 * x * y) \
			+ G[10] * (2 * y * z) \
			+ G[11] * (std::pow(z,2) - (1. / 2) * (std::pow(x,2) + std::pow(y,2))) \
			+ G[12] * (2 * x * z) \
			+ G[13] * (std::pow(x,2) - std::pow(y,2)) \
			+ G[16] * (3 * std::pow(x,2) * y - std::pow(y,3))\
			+ G[17] * (6 * x * y * z)  \
			+ G[18] * (3 * y * std::pow(z,2) - (3./4) * (std::pow(x,2) * y + std::pow(y,3))) \
			+ G[19] * (std::pow(z,3) - (3. / 2) * z * (std::pow(x,2) + std::pow(y,2))) \
			+ G[20] * (3 * x * std::pow(z,2) - (3./4) * (std::pow(x,3) + x * std::pow(y,2))) \
			+ G[21] * (3 * (std::pow(x,2) * z - std::pow(y,2) * z)) \
			+ G[22] * (std::pow(x,3) - 3 * x * std::pow(y,2));


	if (dBidxj != nullptr){

		// Calculating dBxdx
		dBidxj[0][0] = -G[5]/2 + G[7] + 2*G[8]*y - G[10]*y/2 - G[11]*z - \
					3*G[12]*x/2 + 2*G[13]*z + 2*G[14]*x + 6*G[15]*x*y + \
					6*G[16]*y*z - 3*G[17]*x*y - 1.5*G[18]*y*z + \
					G[19]*(1.125*std::pow(x,2) + 0.375*std::pow(y,2) - 1.5*std::pow(z,2)) - \
					4.5*G[20]*x*z + G[21]*(-3*std::pow(x,2) + 3*std::pow(z,2)) + \
					6*G[22]*x*z + G[23]*(3*std::pow(x,2) - 3*std::pow(y,2));

		// Calculating dBxdy
		dBidxj[0][1] = G[3] + 2*G[8]*x + 2*G[9]*z - G[10]*x/2 - G[12]*y/2 - \
					2*G[14]*y + G[15]*(3*std::pow(x,2) - 3*std::pow(y,2)) + 6*G[16]*x*z+\
					G[17]*(-3*std::pow(x,2)/2 - 3*std::pow(y,2)/2 + 3*std::pow(z,2)) - \
					1.5*G[18]*x*z + 0.75*G[19]*x*y - 1.5*G[20]*y*z - \
					6*G[22]*y*z - 6*G[23]*x*y;

		// Calculating dBxdz
		dBidxj[0][2] = G[6] + 2*G[9]*y - G[11]*x + 2*G[12]*z + 2*G[13]*x + \
					6*G[16]*x*y + 6*G[17]*y*z - 1.5*G[18]*x*y - 3.0*G[19]*x*z+\
					G[20]*(-2.25*std::pow(x,2) - 0.75*std::pow(y,2) + 3.0*std::pow(z,2)) + \
					6*G[21]*x*z + G[22]*(3*std::pow(x,2) - 3*std::pow(y,2));

		// Calculating dBydx
		dBidxj[1][0] = G[3] + 2*G[8]*x + 2*G[9]*z - G[10]*x/2 - G[12]*y/2 - \
					2*G[14]*y + G[15]*(3*std::pow(x,2) - 3*std::pow(y,2)) + 6*G[16]*x*z+\
					G[17]*(-3*std::pow(x,2)/2 - 3*std::pow(y,2)/2 + 3*std::pow(z,2)) - \
					1.5*G[18]*x*z + 0.75*G[19]*x*y - 1.5*G[20]*y*z - \
					6*G[22]*y*z - 6*G[23]*x*y;

		// Calculating dBydy
		dBidxj[1][1] = -G[5]/2 - G[7] - 2*G[8]*y - 3*G[10]*y/2 - G[11]*z - \
					G[12]*x/2 - 2*G[13]*z - 2*G[14]*x - 6*G[15]*x*y - \
					6*G[16]*y*z - 3*G[17]*x*y - 4.5*G[18]*y*z + \
					G[19]*(0.375*std::pow(x,2) + 1.125*std::pow(y,2) - 1.5*std::pow(z,2)) - \
					1.5*G[20]*x*z + G[21]*(3*std::pow(y,2) - 3*std::pow(z,2)) - \
					6*G[22]*x*z + G[23]*(-3*std::pow(x,2) + 3*std::pow(y,2));

		// Calculating dBydz
		dBidxj[1][2] = G[4] + 2*G[9]*x + 2*G[10]*z - G[11]*y - 2*G[13]*y + \
					G[16]*(3*std::pow(x,2) - 3*std::pow(y,2)) + 6*G[17]*x*z + \
					G[18]*(-0.75*std::pow(x,2) - 2.25*std::pow(y,2) + 3.0*std::pow(z,2)) - \
					3.0*G[19]*y*z - 1.5*G[20]*x*y - 6*G[21]*y*z - 6*G[22]*x*y;

		// Calculating dBzdx
		dBidxj[2][0] = G[6] + 2*G[9]*y - 1.0*G[11]*x + 2*G[12]*z + 2*G[13]*x + \
					6*G[16]*x*y + 6*G[17]*y*z - 1.5*G[18]*x*y - 3.0*G[19]*x*z+\
					G[20]*(-2.25*std::pow(x,2) - 0.75*std::pow(y,2) + 3*std::pow(z,2)) + \
					6*G[21]*x*z + G[22]*(3*std::pow(x,2) - 3*std::pow(y,2));

		// Calculating dBzdy
		dBidxj[2][1] = G[4] + 2*G[9]*x + 2*G[10]*z - 1.0*G[11]*y - 2*G[13]*y + \
					G[16]*(3*std::pow(x,2) - 3*std::pow(y,2)) + 6*G[17]*x*z + \
					G[18]*(-0.75*std::pow(x,2) - 2.25*std::pow(y,2) + 3*std::pow(z,2)) - \
					3.0*G[19]*y*z - 1.5*G[20]*x*y - 6*G[21]*y*z - 6*G[22]*x*y;

		// Calculating dBzdz
		dBidxj[2][2] = G[5] + 2*G[10]*y + 2*G[11]*z + 2*G[12]*x + 6*G[17]*x*y + \
					6*G[18]*y*z + G[19]*(-1.5*std::pow(x,2) - 1.5*std::pow(y,2) + \
					3*std::pow(z,2)) + 6*G[20]*x*z + G[21]*(3*std::pow(x,2) -3*std::pow(y,2));
	}



	/********************************************************************************************************
	 * ROTATION IS NOT IMPLEMENTED CORRECTLY!
	 * IT JUST ROTATES THE RESULTING MAGNETIC FIELD VECTORS BUT DOES NOT DO A FULL COORDINATE TRANSFORMATION!
	 * CODE BELOW IS JUST LEFT FOR INFORMATIONAL PURPOSES! DO NOT USE!
	*********************************************************************************************************/



	/* 
	Information about Rotations with Quaternions

	from the double-specific constructor documentation of BOOST
	boost.org/doc/libs/1_70_0/libs/math/doc/html/math_toolkit/quat_mem_fun.html

	explicit quaternion(double const & requested_a = 0.0, 
						double const & requested_b = 0.0, 
						double const & requested_c = 0.0, 
						double const & requested_d = 0.0);

	This constructs a quartention. From the useful wikipedia page on rotations
	and quartenions... wikipedia.org/wiki/Quaternions_and_spatial_rotation

	"In a programmatic implementation, this is achieved by constructing a 
	quaternion whose vector part is p and real part equals zero and then
	performing the quaternion multiplication. The vector part of the resulting 
	quaternion is the desired vector pâ€²."

	here they refer to the original vector, which we want to rotate, as p. The 
	resulting, rotated, vector is called p'. Refer to the referenced wikipedia
	page for details on how to construct the desired quartenion q. On that 
	wikipedia page, an example rotation in 3D space is provided. 

	(!!!) due to the limitation of boost version within the UCN cluster, 
	we are not able to use the QVM library (earliest v1.62 of boost) which 
	contains more updated functionality specific to the rotations 
	implemented here. See http://boostorg.github.io/qvm/#quat_rotate
	and https://github.com/boostorg/qvm
	*/

	// The B vector is rotated, as well as the three dBxdxj, dBydxj dBzdxj 
	// directional gradient vectors, using the same quaternion conjugation.
	// This achieves a full rotation of the magnetic field and its spatial 
	// derivatives.

	// if the user provides values of 0 for every input to the axis of rotation
	// then no rotation is performed.
	if (axis_x != 0 || axis_y != 0 || axis_z != 0){

        // construct the quarternion, p, which represents the vector to be 
		// rotated
        // here the 0th component is equal to zero, and the remaining three 
        // components are those of the earlier computed magnetic field
        boost::math::quaternion<double> p(0, B[0], B[1], B[2]);

        // the components of the axis of rotation (member variables of this 
		// class) are used to construct a normalized vector.
        boost::numeric::ublas::vector<double> axis(3, 0);
        axis(0) = axis_x;
        axis(1) = axis_y;
        axis(2) = axis_z;

        // the rotational axis vector is normalized
        axis = (axis / boost::numeric::ublas::norm_2(axis));

        // calculate quarternion, q, whih represents the rotation
        boost::math::quaternion<double> q(std::cos(angle / 2), 
                                          std::sin(angle / 2) * axis(0), 
                                          std::sin(angle / 2) * axis(1), 
                                          std::sin(angle / 2) * axis(2));

        // get the conjugate of the quaternion, q'
        boost::math::quaternion<double> q_prime = boost::math::conj(q);

        // perform multiplication to rotate
        boost::math::quaternion<double> p_prime = q * p * q_prime;

        // extract the resulting vector components, post-rotation
        B[0] = p_prime.R_component_2();
        B[1] = p_prime.R_component_3();
        B[2] = p_prime.R_component_4();

	if (dBidxj != nullptr){
	        // We create three quaternions, one for the gradient of each of the 
	        // gradient vectors

      	  boost::math::quaternion<double> p_x(0, 
      	                                      dBidxj[0][0],
      	                                      dBidxj[0][1],
      	                                      dBidxj[0][2]);

      	  boost::math::quaternion<double> p_y(0, 
      	                                      dBidxj[1][0], 
      	                                      dBidxj[1][1], 
      	                                      dBidxj[1][2]);

      	  boost::math::quaternion<double> p_z(0, 
      	                                      dBidxj[2][0], 
      	                                      dBidxj[2][1], 
      	                                      dBidxj[2][2]);

      	  // we use the same quaternion, q, and conjugate q' for these rotations
      	  boost::math::quaternion<double> p_x_prime = q * p_x * q_prime;
      	  boost::math::quaternion<double> p_y_prime = q * p_y * q_prime;
      	  boost::math::quaternion<double> p_z_prime = q * p_z * q_prime;

      	  // extract the resulting vector components, post-rotation
      	  // assign the components to the dBidxj matrix
      	  dBidxj[0][0] = p_x_prime.R_component_2();
      	  dBidxj[0][1] = p_x_prime.R_component_3();
      	  dBidxj[0][2] = p_x_prime.R_component_4();

      	  dBidxj[1][0] = p_y_prime.R_component_2();
      	  dBidxj[1][1] = p_y_prime.R_component_3();
      	  dBidxj[1][2] = p_y_prime.R_component_4();

      	  dBidxj[2][0] = p_z_prime.R_component_2();
      	  dBidxj[2][1] = p_z_prime.R_component_3();
      	  dBidxj[2][2] = p_z_prime.R_component_4();
	}

    }

	// }
}


