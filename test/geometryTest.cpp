#include <boost/test/unit_test.hpp>

#include "pathing.h"

BOOST_AUTO_TEST_CASE(PathTest){
    std::vector<double> times{0, 1, 2};
    std::vector<std::array<double, 3> > translations{{0,0,0}, {0,0,1}, {0,0,2}};
    std::vector<std::array<double, 3> > velocities{{0,0,1}, {0,0,0}, {0,0,1}};
    std::vector<std::array<double, 3> > rotations{{0,0,0}, {0,0,1}, {0,0,2}};
    std::vector<std::array<double, 3> > angularvelocities{{0,0,1}, {0,0,0}, {0,0,1}};
    TPath path(times, translations, velocities, rotations, angularvelocities);

    auto x0 = path.translation(0);
    auto r0 = path.rotation(0);
    auto v0 = path.velocity(0);
    auto a0 = path.angularVelocity(0);
    auto rv0 = path.relativeVelocity(0, {1,0,0});
    auto p0 = path.passive_transform(0, {1,0,0});
    BOOST_CHECK_EQUAL(x0[0], 0);
    BOOST_CHECK_EQUAL(x0[1], 0);
    BOOST_CHECK_EQUAL(x0[2], 0);
    BOOST_CHECK_EQUAL(r0[0], 0);
    BOOST_CHECK_EQUAL(r0[1], 0);
    BOOST_CHECK_EQUAL(r0[2], 0);
    BOOST_CHECK_EQUAL(v0[0], 0);
    BOOST_CHECK_EQUAL(v0[1], 0);
    BOOST_CHECK_EQUAL(v0[2], 1);
    BOOST_CHECK_EQUAL(a0[0], 0);
    BOOST_CHECK_EQUAL(a0[1], 0);
    BOOST_CHECK_EQUAL(a0[2], 1);
    BOOST_CHECK_EQUAL(rv0[0], 0);
    BOOST_CHECK_EQUAL(rv0[1], 1);
    BOOST_CHECK_EQUAL(rv0[2], 1);
    BOOST_CHECK_EQUAL(p0[0], 1);
    BOOST_CHECK_EQUAL(p0[1], 0);
    BOOST_CHECK_EQUAL(p0[2], 0);

    auto x05 = path.translation(0.5);
    auto r05 = path.rotation(0.5);
    auto v05 = path.velocity(0.5);
    auto a05 = path.angularVelocity(0.5);
    auto rv05 = path.relativeVelocity(0.5, {1,0,0});
    auto p05 = path.passive_transform(0.5, {1,0,0});
    BOOST_CHECK_EQUAL(x05[0], 0);
    BOOST_CHECK_EQUAL(x05[1], 0);
    BOOST_CHECK_EQUAL(x05[2], 0.625);
    BOOST_CHECK_EQUAL(r05[0], 0);
    BOOST_CHECK_EQUAL(r05[1], 0);
    BOOST_CHECK_EQUAL(r05[2], 0.625);
    BOOST_CHECK_EQUAL(v05[0], 0);
    BOOST_CHECK_EQUAL(v05[1], 0);
    BOOST_CHECK_EQUAL(v05[2], 1.25);
    BOOST_CHECK_EQUAL(a05[0], 0);
    BOOST_CHECK_EQUAL(a05[1], 0);
    BOOST_CHECK_EQUAL(a05[2], 1.25);
    BOOST_CHECK_EQUAL(rv05[0], 0);
    BOOST_CHECK_EQUAL(rv05[1], 1.25);
    BOOST_CHECK_EQUAL(rv05[2], 1.25);
    BOOST_CHECK_CLOSE(p05[0], std::cos(0.625), 1e-13);
    BOOST_CHECK_CLOSE(p05[1], -std::sin(0.625), 1e-13);
    BOOST_CHECK_EQUAL(p05[2], -0.625);

    auto x1 = path.translation(1);
    auto r1 = path.rotation(1);
    auto v1 = path.velocity(1);
    auto a1 = path.angularVelocity(1);
    auto rv1 = path.relativeVelocity(1, {1,0,0});
    auto p1 = path.passive_transform(1, {1,0,0});
    BOOST_CHECK_EQUAL(x1[0], 0);
    BOOST_CHECK_EQUAL(x1[1], 0);
    BOOST_CHECK_EQUAL(x1[2], 1);
    BOOST_CHECK_EQUAL(r1[0], 0);
    BOOST_CHECK_EQUAL(r1[1], 0);
    BOOST_CHECK_EQUAL(r1[2], 1);
    BOOST_CHECK_EQUAL(v1[0], 0);
    BOOST_CHECK_EQUAL(v1[1], 0);
    BOOST_CHECK_EQUAL(v1[2], 0);
    BOOST_CHECK_EQUAL(a1[0], 0);
    BOOST_CHECK_EQUAL(a1[1], 0);
    BOOST_CHECK_EQUAL(a1[2], 0);
    BOOST_CHECK_EQUAL(rv1[0], 0);
    BOOST_CHECK_EQUAL(rv1[1], 0);
    BOOST_CHECK_EQUAL(rv1[2], 0);
    BOOST_CHECK_CLOSE(p1[0], std::cos(1), 1e-13);
    BOOST_CHECK_CLOSE(p1[1], -std::sin(1), 1e-13);
    BOOST_CHECK_EQUAL(p1[2], -1);

    auto x2 = path.translation(2);
    auto r2 = path.rotation(2);
    auto v2 = path.velocity(2);
    auto a2 = path.angularVelocity(2);
    auto rv2 = path.relativeVelocity(2, {1,0,0});
    auto p2 = path.passive_transform(2, {1,0,0});
    BOOST_CHECK_EQUAL(x2[0], 0);
    BOOST_CHECK_EQUAL(x2[1], 0);
    BOOST_CHECK_EQUAL(x2[2], 2);
    BOOST_CHECK_EQUAL(r2[0], 0);
    BOOST_CHECK_EQUAL(r2[1], 0);
    BOOST_CHECK_EQUAL(r2[2], 2);
    BOOST_CHECK_EQUAL(v2[0], 0);
    BOOST_CHECK_EQUAL(v2[1], 0);
    BOOST_CHECK_EQUAL(v2[2], 1);
    BOOST_CHECK_EQUAL(a2[0], 0);
    BOOST_CHECK_EQUAL(a2[1], 0);
    BOOST_CHECK_EQUAL(a2[2], 1);
    BOOST_CHECK_EQUAL(rv2[0], 0);
    BOOST_CHECK_EQUAL(rv2[1], 1);
    BOOST_CHECK_EQUAL(rv2[2], 1);
    BOOST_CHECK_CLOSE(p2[0], std::cos(2), 1e-13);
    BOOST_CHECK_CLOSE(p2[1], -std::sin(2), 1e-13);
    BOOST_CHECK_EQUAL(p2[2], -2);

    auto x3 = path.translation(3);
    auto r3 = path.rotation(3);
    auto v3 = path.velocity(3);
    auto a3 = path.angularVelocity(3);
    auto rv3 = path.relativeVelocity(3, {1,0,0});
    auto p3 = path.passive_transform(3, {1,0,0});
    BOOST_CHECK_EQUAL(x3[0], 0);
    BOOST_CHECK_EQUAL(x3[1], 0);
    BOOST_CHECK_EQUAL(x3[2], 3);
    BOOST_CHECK_EQUAL(r3[0], 0);
    BOOST_CHECK_EQUAL(r3[1], 0);
    BOOST_CHECK_EQUAL(r3[2], 3);
    BOOST_CHECK_EQUAL(v3[0], 0);
    BOOST_CHECK_EQUAL(v3[1], 0);
    BOOST_CHECK_EQUAL(v3[2], 1);
    BOOST_CHECK_EQUAL(a3[0], 0);
    BOOST_CHECK_EQUAL(a3[1], 0);
    BOOST_CHECK_EQUAL(a3[2], 1);
    BOOST_CHECK_EQUAL(rv3[0], 0);
    BOOST_CHECK_EQUAL(rv3[1], 1);
    BOOST_CHECK_EQUAL(rv3[2], 1);
    BOOST_CHECK_CLOSE(p3[0], std::cos(3), 1e-13);
    BOOST_CHECK_CLOSE(p3[1], -std::sin(3), 1e-13);
    BOOST_CHECK_EQUAL(p3[2], -3);

    auto xm1 = path.translation(-1);
    auto rm1 = path.rotation(-1);
    auto vm1 = path.velocity(-1);
    auto am1 = path.angularVelocity(-1);
    auto rvm1 = path.relativeVelocity(-1, {1,0,0});
    auto pm1 = path.passive_transform(-1, {1,0,0});
    BOOST_CHECK_EQUAL(xm1[0], 0);
    BOOST_CHECK_EQUAL(xm1[1], 0);
    BOOST_CHECK_EQUAL(xm1[2], -1);
    BOOST_CHECK_EQUAL(rm1[0], 0);
    BOOST_CHECK_EQUAL(rm1[1], 0);
    BOOST_CHECK_EQUAL(rm1[2], -1);
    BOOST_CHECK_EQUAL(vm1[0], 0);
    BOOST_CHECK_EQUAL(vm1[1], 0);
    BOOST_CHECK_EQUAL(vm1[2], 1);
    BOOST_CHECK_EQUAL(am1[0], 0);
    BOOST_CHECK_EQUAL(am1[1], 0);
    BOOST_CHECK_EQUAL(am1[2], 1);
    BOOST_CHECK_EQUAL(rvm1[0], 0);
    BOOST_CHECK_EQUAL(rvm1[1], 1);
    BOOST_CHECK_EQUAL(rvm1[2], 1);
    BOOST_CHECK_CLOSE(pm1[0], std::cos(-1), 1e-13);
    BOOST_CHECK_CLOSE(pm1[1], -std::sin(-1), 1e-13);
    BOOST_CHECK_EQUAL(pm1[2], 1);

}
